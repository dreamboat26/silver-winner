{"docstore/metadata": {"53698dd9-2af4-45d2-8713-69b10f4d8fc7": {"doc_hash": "7feb985d58b13537452285d5cd8af01ec3927c611b71b11eeb81e3f1a8e067a3"}, "61d4ba21-23ff-4896-84b5-383268ffd7e7": {"doc_hash": "dc73ec878c504beb65a0cdf3f429e4bbba344fa89ba85ce07ccc3eb936de4284"}, "badcc825-0f13-465b-a7d0-9233ad7ce9f4": {"doc_hash": "6b67f1110fed283f2a65dc09fa9a01cb85676c3844939ab021c310c12bcd9bd2"}, "3284ad6e-16df-4361-beeb-1b3b57d84db8": {"doc_hash": "97ba220f85cbf49ce779a71fd2e433af4f66a04dfa35eb4e25e702f5fc220992"}, "484f711e-fb86-41b8-985e-c0d990b1a15b": {"doc_hash": "a3d2fa05a532ec2db0d8ed78e21ef1df6bfdb509333cf60d1ea30728ec6e9d00"}, "1e81c91b-809e-4a41-b076-b0cfb5739c1b": {"doc_hash": "63cb9a4f8c0cd99a59ba9ca5b20ce4c2a3ef3022e518fe1b449933d413737429"}, "f32145fa-ead5-4662-ac90-e3d4a8035fdb": {"doc_hash": "233c9773159cfe1858e6bf16dbeb89950d35a618f133cfe9844720b20a689826"}, "95d77b17-4e5f-4242-bd6d-75d17960a6f0": {"doc_hash": "2c99fc5c18a4e0d845295dd0b7e041f73944f7bd3f62e8ec814468e76c2a7861"}, "e3a95ead-de58-406f-a984-9a8ac0226fe8": {"doc_hash": "0022c7946633061e7f4b89f58e413a2e9b38485f802fd5969b61aaf701efa3a8"}, "d142f2e6-7205-4757-a0d3-040db4c15207": {"doc_hash": "c9a75cbd9d44529639773eaae336645cda6c88e075d0dd279feb285aa62fd0c7"}, "4c01f7c1-d404-4af4-92b9-32253d5a7e24": {"doc_hash": "d9b5c31d1cb847f964fe8a20450f4f50af7ccbe341941be4ebe00dfa42fb11dc"}, "16ba6dc7-7fb4-4f73-a285-f941ba5c8957": {"doc_hash": "64996288b3a93139d008d641206634b8bb7c367cefede2562f71a80d4b8d76cb"}, "f8cb7794-6457-4b28-bbae-34da3005dc12": {"doc_hash": "e08482bc89a42c20098ff786c829f8acca038f7b10f27e246ffb2e230dd0e857"}, "e15dd2ed-fc8a-4274-9547-6d1c9fac7f0c": {"doc_hash": "62c0d8dd4b446fa4e112bc0a1417aafd18bff634a6abd432fcf31356ec75f50d"}, "27cc80eb-f98e-463e-9924-722164a23f85": {"doc_hash": "e0b5bbe01bf46493409bba75da22d4f95137e3162ccbfa001cfd1f8a93b472f7"}, "f0be8333-e3e3-4bb8-84a0-eab9a0dc8160": {"doc_hash": "98b5a46ca191240cd63d8004da1f21f4d18ae1298b17df7626fbb9a3c58ecfd3"}, "6fe34fd6-0dfa-48d5-aa72-2dc25c641aab": {"doc_hash": "2740fdcff666297edcb0b9519558be04b9e04642de2f761fda2ae896fda28b9f"}, "3e3b8b50-efd3-43a4-bc8c-c44eec407d0d": {"doc_hash": "556d5fc10a97401044b9beb5207a8d9c860b77cbefe0c955f4d70132cd3ecba8"}, "054daa24-aad0-4c7a-ab80-9e0ab3b6b79c": {"doc_hash": "a07e4aadf7c19205e7160c83e5e221a5801ab727974388dc96b2ac3c834eb742"}, "4c31e580-66dc-419c-ad46-632efd7eccd3": {"doc_hash": "911624fbbf46c357ea12ab81b929477f1814fe5504c150f8e124d5a3b267cee5"}, "cf23858f-f79b-4952-9238-686d4c6c1c44": {"doc_hash": "7dc35039d78da4a4c6703c9c946fda02a7803264e15d26fd50f9dea4f83b8279"}, "f3293f98-bd55-4dbc-9082-d6a5553d3a6f": {"doc_hash": "b34d0a3b766e45895c733c67a281c9ffc6a1d6e2696e12945811cf954d7da7ff"}, "c0c687d3-f585-44d7-8dc6-a255605c65a6": {"doc_hash": "ac0c40c4902b10b95d636aa7058a9ac018b9d993b4251d4bd585565506cafe2f"}, "938e0625-f274-441e-bea3-f3c0e0405a34": {"doc_hash": "f55ed7cb1a1182da1985b05acf6ee689167d2bfd51ebae1d2481f1ce32727b07"}, "f796d7eb-9ba5-4dd6-ac9d-db206b73d509": {"doc_hash": "64891da4b01f590a5d2952c4717598c2272ab238a0b1b52a84209f44c9360f86"}, "2f6dde63-292b-4062-8b75-070b746dc358": {"doc_hash": "0916b1d126bae2d61698ffde337570805a41709a99cc3f916f76ae0d0f482ea3"}, "41042fcc-2be2-4b46-b797-53401d8fcca6": {"doc_hash": "0357f4a58a7e30d78940119ed273302262b604195a25fd0c464bb114f3af33ff"}, "4f525a47-cf11-408c-b008-d2f5c9bf5b18": {"doc_hash": "9837509f43ad3d8ebf19933acd4adf84381d87ad11fcc2fe032ef3404ae91adf"}, "f3a8e7c4-b7a3-4535-9d42-52a01e757453": {"doc_hash": "e10468a585cf4d19721167bcc88ce4324df1e69a895724181991d79f4cf5f569"}, "8c8c431d-e586-48ca-b52f-5b11f1cb2c59": {"doc_hash": "c0a930cc76dd24d1e84e8afae63cc6f2eb1ec71aebacf427f6d72f4fa5a3eb8b"}, "90ef0338-485f-4924-a410-c883a34207e8": {"doc_hash": "99c00bc4b19e418ff900f5728a76d33bd4f67d101dcaf15fbf197e1522094a8c"}, "46f8ad9f-4f87-4dac-b700-ed4ce553c6e7": {"doc_hash": "2ea19d900506cc58cdca45a21676e1bc43488eb801bee02626e857cba4e16fb7"}, "2f93ecdd-2c7a-4612-905b-7bbd784a93ee": {"doc_hash": "f16e87334f8a230d6cec93ecded65a7f2daaffbf716fe0d959a4777bcc2501d5"}, "c0934c99-c258-4db8-93bf-21cae9061ec9": {"doc_hash": "8152bd269b6d5407cd655aadc61bd5bb39cf08e110d17be80d2ffc4d057e9ba6"}, "5ef7d2dd-642c-4542-8b36-2632ad62b649": {"doc_hash": "39dbbb1f1c54fdb94a9371ecb98cf036aeb8deb5de8e6d6b01e81961c4fc169f"}, "b9897658-0aa1-42b0-85b2-2b5c268a46d9": {"doc_hash": "8cc78603885a25b8881cbf39b671ad0ef819b744e0059262dde9eaabea02b978"}, "407d15ae-3626-4ad1-86c8-8a317ed7c239": {"doc_hash": "fce2370635177c3891b1c5c998946066d07b8b11a3bec03840f9d2e38d394411"}, "993a248f-88b6-4a11-b667-e06da5b544c7": {"doc_hash": "e5e5777c1314573ade85026e160947913aa6c09fae4a0bedccb5a843441e3266"}, "c1ab1442-911c-4801-ae63-25a9f1d9d4b5": {"doc_hash": "2a0627297c5fedb734c2dd77252f0a9eeddc5b5fa8e41df8cbc00986ac8a19ed"}, "0d7166cf-b1cb-4653-a649-45cb053056f5": {"doc_hash": "77e32e6d7d3ba770c4b5b560ad9bd9f58cf69a002a024948a2cbc0ff3d0be972"}, "8dca20f4-c071-411c-ae8f-a712714a5b97": {"doc_hash": "a905e00d191753d39045e3d0ea8d2ef04df33555745a35445e7d849fadd5032c"}, "677bdc8e-44ed-4fb5-a694-1fe9c14e5344": {"doc_hash": "2fd2fcb44b96c605f377d92c95577560cb183e5eb034184b176d0ea8ca0a5860"}, "557da04d-193f-4920-a464-4b57c431255a": {"doc_hash": "81569864881b27b41b3d64371def1cbe53c714f83f97a93910949245c149f7a3"}, "9e655577-b8fb-48ff-a206-5d4567bd3147": {"doc_hash": "117ed20e71ee4818d7fc5f7bc5deba55c18241c7ee37b73c13a10af448054fd0"}, "7ff97c66-6031-49e9-9e65-078432375089": {"doc_hash": "b9ec56d95ff290992d5e84e35c8f48670afba550b036d9a3aa15f76ba2091e18"}}, "docstore/data": {"53698dd9-2af4-45d2-8713-69b10f4d8fc7": {"__data__": {"id_": "53698dd9-2af4-45d2-8713-69b10f4d8fc7", "embedding": null, "metadata": {"filename": "index.md", "extension": ".md", "file_path": "modules/agent/index", "file_name": "index.md", "file_type": "text/markdown", "file_size": 649, "creation_date": "2024-03-08", "last_modified_date": "2024-03-02", "summary": "The LlamaIndex documentation page explains the concept of agents, which are automated reasoning engines that process user queries. It details agent components like breaking down questions, selecting tools, task planning, and task memory. Users can utilize built-in agents like the OpenAI Agent or create custom ones for various tasks."}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "# Agents\n\nAn \u201cagent\u201d is an automated reasoning and decision engine. It takes in a user input/query and can make internal decisions for executing that query in order to return the correct result. The key agent components can include, but are not limited to:\n\n- Breaking down a complex question into smaller ones\n- Choosing an external Tool to use + coming up with parameters for calling the Tool\n- Planning out a set of tasks\n- Storing previously completed tasks in a memory module\n\n## Getting Started\n\nLlamaIndex.TS comes with a few built-in agents, but you can also create your own. The built-in agents include:\n\n- OpenAI Agent\n", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "Document"}, "__type__": "4"}, "61d4ba21-23ff-4896-84b5-383268ffd7e7": {"__data__": {"id_": "61d4ba21-23ff-4896-84b5-383268ffd7e7", "embedding": null, "metadata": {"filename": "multi_document_agent.mdx", "extension": ".mdx", "file_path": "modules/agent/multi_document_agent", "file_name": "multi_document_agent.mdx", "file_size": 8190, "creation_date": "2024-03-08", "last_modified_date": "2024-03-02", "summary": "The documentation outlines setting up a multi-document agent for answering various types of questions over a collection of documents. It covers installing necessary libraries, downloading data from Wikipedia, loading data into LlamaIndex, building document agents for each country, creating a top-level agent for answering questions, and using the agent to retrieve information effectively."}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "# Multi-Document Agent\n\nIn this guide, you learn towards setting up an agent that can effectively answer different types of questions over a larger set of documents.\n\nThese questions include the following\n\n- QA over a specific doc\n- QA comparing different docs\n- Summaries over a specific doc\n- Comparing summaries between different docs\n\nWe do this with the following architecture:\n\n- setup a \u201cdocument agent\u201d over each Document: each doc agent can do QA/summarization within its doc\n- setup a top-level agent over this set of document agents. Do tool retrieval and then do CoT over the set of tools to answer a question.\n\n## Setup and Download Data\n\nWe first start by installing the necessary libraries and downloading the data.\n\n```bash\npnpm i llamaindex\n```\n\n```ts\nimport {\n  Document,\n  ObjectIndex,\n  OpenAI,\n  OpenAIAgent,\n  QueryEngineTool,\n  SimpleNodeParser,\n  SimpleToolNodeMapping,\n  SummaryIndex,\n  VectorStoreIndex,\n  serviceContextFromDefaults,\n  storageContextFromDefaults,\n} from \"llamaindex\";\n```\n\nAnd then for the data we will run through a list of countries and download the wikipedia page for each country.\n\n```ts\nimport fs from \"fs\";\nimport path from \"path\";\n\nconst dataPath = path.join(__dirname, \"tmp_data\");\n\nconst extractWikipediaTitle = async (title: string) => {\n  const fileExists = fs.existsSync(path.join(dataPath, `${title}.txt`));\n\n  if (fileExists) {\n    console.log(`File already exists for the title: ${title}`);\n    return;\n  }\n\n  const queryParams = new URLSearchParams({\n    action: \"query\",\n    format: \"json\",\n    titles: title,\n    prop: \"extracts\",\n    explaintext: \"true\",\n  });\n\n  const url = `https://en.wikipedia.org/w/api.php?${queryParams}`;\n\n  const response = await fetch(url);\n  const data: any = await response.json();\n\n  const pages = data.query.pages;\n  const page = pages[Object.keys(pages)[0]];\n  const wikiText = page.extract;\n\n  await new Promise((resolve) => {\n    fs.writeFile(path.join(dataPath, `${title}.txt`), wikiText, (err: any) => {\n      if (err) {\n        console.error(err);\n        resolve(title);\n        return;\n      }\n      console.log(`${title} stored in file!`);\n\n      resolve(title);\n    });\n  });\n};\n```\n\n```ts\nexport const extractWikipedia = async (titles: string[]) => {\n  if (!fs.existsSync(dataPath)) {\n    fs.mkdirSync(dataPath);\n  }\n\n  for await (const title of titles) {\n    await extractWikipediaTitle(title);\n  }\n\n  console.log(\"Extration finished!\");\n```\n\nThese files will be saved in the `tmp_data` folder.\n\nNow we can call the function to download the data for each country.\n\n```ts\nawait extractWikipedia([\n  \"Brazil\",\n  \"United States\",\n  \"Canada\",\n  \"Mexico\",\n  \"Argentina\",\n  \"Chile\",\n  \"Colombia\",\n  \"Peru\",\n  \"Venezuela\",\n  \"Ecuador\",\n  \"Bolivia\",\n  \"Paraguay\",\n  \"Uruguay\",\n  \"Guyana\",\n  \"Suriname\",\n  \"French Guiana\",\n  \"Falkland Islands\",\n]);\n```\n\n## Load the data\n\nNow that we have the data, we can load it into the LlamaIndex and store as a document.\n\n```ts\nimport { Document } from \"llamaindex\";\n\nconst countryDocs: Record<string, Document> = {};\n\nfor (const title of wikiTitles) {\n  const path = `./agent/helpers/tmp_data/${title}.txt`;\n  const text = await fs.readFile(path, \"utf-8\");\n  const document = new Document({ text: text, id_: path });\n  countryDocs[title] = document;\n}\n```\n\n## Setup LLM and StorageContext\n\nWe will be using gpt-4 for this example and we will use the `StorageContext` to store the documents in-memory.\n\n```ts\nconst llm = new OpenAI({\n  model: \"gpt-4\",\n});\n\nconst ctx = serviceContextFromDefaults({ llm });\n\nconst storageContext = await storageContextFromDefaults({\n  persistDir: \"./storage\",\n});\n```\n\n## Building Multi-Document Agents\n\nIn this section we show you how to construct the multi-document agent. We first build a document agent for each document, and then define the top-level parent agent with an object index.\n\n```ts\nconst documentAgents: Record<string, any> = {};\nconst queryEngines: Record<string, any> = {};\n```\n\nNow we iterate over each country and create a document agent for each one.\n\n### Build Agent for each Document\n\nIn this section we define \u201cdocument agents\u201d for each document.\n\nWe define both a vector index (for semantic search) and summary index (for summarization) for each document. The two query engines are then converted into tools that are passed to an OpenAI function calling agent.\n\nThis document agent can dynamically choose to perform semantic search or summarization within a given document.\n\nWe create a separate document agent for each coutnry.\n\n```ts\nfor (const title of wikiTitles) {\n  // parse the document into nodes\n  const nodes = new SimpleNodeParser({\n    chunkSize: 200,\n    chunkOverlap: 20,\n  }).getNodesFromDocuments([countryDocs[title]]);\n\n  // create the vector index for specific search\n  const vectorIndex = await VectorStoreIndex.init({\n    serviceContext: serviceContext,\n    storageContext: storageContext,\n    nodes,\n  });\n\n  // create the summary index for broader search\n  const summaryIndex = await SummaryIndex.init({\n    serviceContext: serviceContext,\n    nodes,\n  });\n\n  const vectorQueryEngine = summaryIndex.asQueryEngine();\n  const summaryQueryEngine = summaryIndex.asQueryEngine();\n\n  // create the query engines for each task\n  const queryEngineTools = [\n    new QueryEngineTool({\n      queryEngine: vectorQueryEngine,\n      metadata: {\n        name: \"vector_tool\",\n        description: `Useful for questions related to specific aspects of ${title} (e.g. the history, arts and culture, sports, demographics, or more).`,\n      },\n    }),\n    new QueryEngineTool({\n      queryEngine: summaryQueryEngine,\n      metadata: {\n        name: \"summary_tool\",\n        description: `Useful for any requests that require a holistic summary of EVERYTHING about ${title}. For questions about more specific sections, please use the vector_tool.`,\n      },\n    }),\n  ];\n\n  // create the document agent\n  const agent = new OpenAIAgent({\n    tools: queryEngineTools,\n    llm,\n    verbose: true,\n  });\n\n  documentAgents[title] = agent;\n  queryEngines[title] = vectorIndex.asQueryEngine();\n}\n```\n\n## Build Top-Level Agent\n\nNow we define the top-level agent that can answer questions over the set of document agents.\n\nThis agent takes in all document agents as tools. This specific agent RetrieverOpenAIAgent performs tool retrieval before tool use (unlike a default agent that tries to put all tools in the prompt).\n\nHere we use a top-k retriever, but we encourage you to customize the tool retriever method!\n\nFirstly, we create a tool for each document agent\n\n```ts\nconst allTools: QueryEngineTool[] = [];\n```\n\n```ts\nfor (const title of wikiTitles) {\n  const wikiSummary = `\n    This content contains Wikipedia articles about ${title}.\n    Use this tool if you want to answer any questions about ${title}\n  `;\n\n  const docTool = new QueryEngineTool({\n    queryEngine: documentAgents[title],\n    metadata: {\n      name: `tool_${title}`,\n      description: wikiSummary,\n    },\n  });\n\n  allTools.push(docTool);\n}\n```\n\nOur top level agent will use this document agents as tools and use toolRetriever to retrieve the best tool to answer a question.\n\n```ts\n// map the tools to nodes\nconst toolMapping = SimpleToolNodeMapping.fromObjects(allTools);\n\n// create the object index\nconst objectIndex = await ObjectIndex.fromObjects(\n  allTools,\n  toolMapping,\n  VectorStoreIndex,\n  {\n    serviceContext,\n    storageContext,\n  },\n);\n\n// create the top agent\nconst topAgent = new OpenAIAgent({\n  toolRetriever: await objectIndex.asRetriever({}),\n  llm,\n  verbose: true,\n  prefixMessages: [\n    {\n      content:\n        \"You are an agent designed to answer queries about a set of given countries. Please always use the tools provided to answer a question. Do not rely on prior knowledge.\",\n      role: \"system\",\n    },\n  ],\n});\n```\n\n## Use the Agent\n\nNow we can use the agent to answer questions.\n\n```ts\nconst response = await topAgent.chat({\n  message: \"Tell me the differences between Brazil and Canada economics?\",\n});\n\n// print output\nconsole.log(response);\n```\n\nYou can find the full code for this example here\n", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "Document"}, "__type__": "4"}, "badcc825-0f13-465b-a7d0-9233ad7ce9f4": {"__data__": {"id_": "badcc825-0f13-465b-a7d0-9233ad7ce9f4", "embedding": null, "metadata": {"filename": "openai.mdx", "extension": ".mdx", "file_path": "modules/agent/openai", "file_name": "openai.mdx", "file_size": 3985, "creation_date": "2024-03-08", "last_modified_date": "2024-03-02", "summary": "The LlamaIndex documentation page introduces the OpenAI Agent API for creating custom agents. It demonstrates setting up the agent, defining functions to sum and divide numbers, creating function tools with JSON schemas, and interacting with the agent through chat. The tutorial provides a comprehensive guide on building and utilizing an OpenAI agent."}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "---\nsidebar_position: 0\n---\n\n# OpenAI Agent\n\nOpenAI API that supports function calling, it\u2019s never been easier to build your own agent!\n\nIn this notebook tutorial, we showcase how to write your own OpenAI agent\n\n## Setup\n\nFirst, you need to install the `llamaindex` package. You can do this by running the following command in your terminal:\n\n```bash\npnpm i llamaindex\n```\n\nThen we can define a function to sum two numbers and another function to divide two numbers.\n\n```ts\nfunction sumNumbers({ a, b }: { a: number; b: number }): number {\n  return a + b;\n}\n\n// Define a function to divide two numbers\nfunction divideNumbers({ a, b }: { a: number; b: number }): number {\n  return a / b;\n}\n```\n\n## Create a function tool\n\nNow we can create a function tool from the sum function and another function tool from the divide function.\n\nFor the parameters of the sum function, we can define a JSON schema.\n\n### JSON Schema\n\n```ts\nconst sumJSON = {\n  type: \"object\",\n  properties: {\n    a: {\n      type: \"number\",\n      description: \"The first number\",\n    },\n    b: {\n      type: \"number\",\n      description: \"The second number\",\n    },\n  },\n  required: [\"a\", \"b\"],\n};\n\nconst divideJSON = {\n  type: \"object\",\n  properties: {\n    a: {\n      type: \"number\",\n      description: \"The dividend a to divide\",\n    },\n    b: {\n      type: \"number\",\n      description: \"The divisor b to divide by\",\n    },\n  },\n  required: [\"a\", \"b\"],\n};\n\nconst sumFunctionTool = new FunctionTool(sumNumbers, {\n  name: \"sumNumbers\",\n  description: \"Use this function to sum two numbers\",\n  parameters: sumJSON,\n});\n\nconst divideFunctionTool = new FunctionTool(divideNumbers, {\n  name: \"divideNumbers\",\n  description: \"Use this function to divide two numbers\",\n  parameters: divideJSON,\n});\n```\n\n## Create an OpenAIAgent\n\nNow we can create an OpenAIAgent with the function tools.\n\n```ts\nconst agent = new OpenAIAgent({\n  tools: [sumFunctionTool, divideFunctionTool],\n  verbose: true,\n});\n```\n\n## Chat with the agent\n\nNow we can chat with the agent.\n\n```ts\nconst response = await agent.chat({\n  message: \"How much is 5 + 5? then divide by 2\",\n});\n\nconsole.log(String(response));\n```\n\n## Full code\n\n```ts\nimport { FunctionTool, OpenAIAgent } from \"llamaindex\";\n\n// Define a function to sum two numbers\nfunction sumNumbers({ a, b }: { a: number; b: number }): number {\n  return a + b;\n}\n\n// Define a function to divide two numbers\nfunction divideNumbers({ a, b }: { a: number; b: number }): number {\n  return a / b;\n}\n\n// Define the parameters of the sum function as a JSON schema\nconst sumJSON = {\n  type: \"object\",\n  properties: {\n    a: {\n      type: \"number\",\n      description: \"The first number\",\n    },\n    b: {\n      type: \"number\",\n      description: \"The second number\",\n    },\n  },\n  required: [\"a\", \"b\"],\n};\n\n// Define the parameters of the divide function as a JSON schema\nconst divideJSON = {\n  type: \"object\",\n  properties: {\n    a: {\n      type: \"number\",\n      description: \"The argument a to divide\",\n    },\n    b: {\n      type: \"number\",\n      description: \"The argument b to divide\",\n    },\n  },\n  required: [\"a\", \"b\"],\n};\n\nasync function main() {\n  // Create a function tool from the sum function\n  const sumFunctionTool = new FunctionTool(sumNumbers, {\n    name: \"sumNumbers\",\n    description: \"Use this function to sum two numbers\",\n    parameters: sumJSON,\n  });\n\n  // Create a function tool from the divide function\n  const divideFunctionTool = new FunctionTool(divideNumbers, {\n    name: \"divideNumbers\",\n    description: \"Use this function to divide two numbers\",\n    parameters: divideJSON,\n  });\n\n  // Create an OpenAIAgent with the function tools\n  const agent = new OpenAIAgent({\n    tools: [sumFunctionTool, divideFunctionTool],\n    verbose: true,\n  });\n\n  // Chat with the agent\n  const response = await agent.chat({\n    message: \"How much is 5 + 5? then divide by 2\",\n  });\n\n  // Print the response\n  console.log(String(response));\n}\n\nmain().then(() => {\n  console.log(\"Done\");\n});\n```\n", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "Document"}, "__type__": "4"}, "3284ad6e-16df-4361-beeb-1b3b57d84db8": {"__data__": {"id_": "3284ad6e-16df-4361-beeb-1b3b57d84db8", "embedding": null, "metadata": {"filename": "query_engine_tool.mdx", "extension": ".mdx", "file_path": "modules/agent/query_engine_tool", "file_name": "query_engine_tool.mdx", "file_size": 2999, "creation_date": "2024-03-08", "last_modified_date": "2024-03-02", "summary": "The documentation page guides users on setting up a QueryEngineTool to query a vector index created from documents using the LlamaIndex package. It demonstrates creating an OpenAIAgent with the QueryEngineTool to interact through chat, showcasing the process from index creation to chatting with the agent."}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "---\nsidebar_position: 1\n---\n\n# OpenAI Agent + QueryEngineTool\n\nQueryEngineTool is a tool that allows you to query a vector index. In this example, we will create a vector index from a set of documents and then create a QueryEngineTool from the vector index. We will then create an OpenAIAgent with the QueryEngineTool and chat with the agent.\n\n## Setup\n\nFirst, you need to install the `llamaindex` package. You can do this by running the following command in your terminal:\n\n```bash\npnpm i llamaindex\n```\n\nThen you can import the necessary classes and functions.\n\n```ts\nimport {\n  OpenAIAgent,\n  SimpleDirectoryReader,\n  VectorStoreIndex,\n  QueryEngineTool,\n} from \"llamaindex\";\n```\n\n## Create a vector index\n\nNow we can create a vector index from a set of documents.\n\n```ts\n// Load the documents\nconst documents = await new SimpleDirectoryReader().loadData({\n  directoryPath: \"node_modules/llamaindex/examples/\",\n});\n\n// Create a vector index from the documents\nconst vectorIndex = await VectorStoreIndex.fromDocuments(documents);\n```\n\n## Create a QueryEngineTool\n\nNow we can create a QueryEngineTool from the vector index.\n\n```ts\n// Create a query engine from the vector index\nconst abramovQueryEngine = vectorIndex.asQueryEngine();\n\n// Create a QueryEngineTool with the query engine\nconst queryEngineTool = new QueryEngineTool({\n  queryEngine: abramovQueryEngine,\n  metadata: {\n    name: \"abramov_query_engine\",\n    description: \"A query engine for the Abramov documents\",\n  },\n});\n```\n\n## Create an OpenAIAgent\n\n```ts\n// Create an OpenAIAgent with the query engine tool tools\n\nconst agent = new OpenAIAgent({\n  tools: [queryEngineTool],\n  verbose: true,\n});\n```\n\n## Chat with the agent\n\nNow we can chat with the agent.\n\n```ts\nconst response = await agent.chat({\n  message: \"What was his salary?\",\n});\n\nconsole.log(String(response));\n```\n\n## Full code\n\n```ts\nimport {\n  OpenAIAgent,\n  SimpleDirectoryReader,\n  VectorStoreIndex,\n  QueryEngineTool,\n} from \"llamaindex\";\n\nasync function main() {\n  // Load the documents\n  const documents = await new SimpleDirectoryReader().loadData({\n    directoryPath: \"node_modules/llamaindex/examples/\",\n  });\n\n  // Create a vector index from the documents\n  const vectorIndex = await VectorStoreIndex.fromDocuments(documents);\n\n  // Create a query engine from the vector index\n  const abramovQueryEngine = vectorIndex.asQueryEngine();\n\n  // Create a QueryEngineTool with the query engine\n  const queryEngineTool = new QueryEngineTool({\n    queryEngine: abramovQueryEngine,\n    metadata: {\n      name: \"abramov_query_engine\",\n      description: \"A query engine for the Abramov documents\",\n    },\n  });\n\n  // Create an OpenAIAgent with the function tools\n  const agent = new OpenAIAgent({\n    tools: [queryEngineTool],\n    verbose: true,\n  });\n\n  // Chat with the agent\n  const response = await agent.chat({\n    message: \"What was his salary?\",\n  });\n\n  // Print the response\n  console.log(String(response));\n}\n\nmain().then(() => {\n  console.log(\"Done\");\n});\n```\n", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "Document"}, "__type__": "4"}, "484f711e-fb86-41b8-985e-c0d990b1a15b": {"__data__": {"id_": "484f711e-fb86-41b8-985e-c0d990b1a15b", "embedding": null, "metadata": {"filename": "react_agent.mdx", "extension": ".mdx", "file_path": "modules/agent/react_agent", "file_name": "react_agent.mdx", "file_size": 4591, "creation_date": "2024-03-08", "last_modified_date": "2024-03-02", "summary": "Learn to create a ReAct agent using the `llamaindex` package. Define functions to sum and divide numbers, create function tools with JSON schemas, and interact with the agent to perform calculations. The agent reasons, executes actions, and provides answers based on defined tools, showcasing AI capabilities in task completion."}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "# ReAct Agent\n\nThe ReAct agent is an AI agent that can reason over the next action, construct an action command, execute the action, and repeat these steps in an iterative loop until the task is complete.\n\nIn this notebook tutorial, we showcase how to write your ReAct agent using the `llamaindex` package.\n\n## Setup\n\nFirst, you need to install the `llamaindex` package. You can do this by running the following command in your terminal:\n\n```bash\npnpm i llamaindex\n```\n\nAnd then you can import the `OpenAIAgent` and `FunctionTool` from the `llamaindex` package.\n\n```ts\nimport { FunctionTool, OpenAIAgent } from \"llamaindex\";\n```\n\nThen we can define a function to sum two numbers and another function to divide two numbers.\n\n```ts\nfunction sumNumbers({ a, b }: { a: number; b: number }): number {\n  return a + b;\n}\n\n// Define a function to divide two numbers\nfunction divideNumbers({ a, b }: { a: number; b: number }): number {\n  return a / b;\n}\n```\n\n## Create a function tool\n\nNow we can create a function tool from the sum function and another function tool from the divide function.\n\nFor the parameters of the sum function, we can define a JSON schema.\n\n### JSON Schema\n\n```ts\nconst sumJSON = {\n  type: \"object\",\n  properties: {\n    a: {\n      type: \"number\",\n      description: \"The first number\",\n    },\n    b: {\n      type: \"number\",\n      description: \"The second number\",\n    },\n  },\n  required: [\"a\", \"b\"],\n};\n\nconst divideJSON = {\n  type: \"object\",\n  properties: {\n    a: {\n      type: \"number\",\n      description: \"The dividend a to divide\",\n    },\n    b: {\n      type: \"number\",\n      description: \"The divisor b to divide by\",\n    },\n  },\n  required: [\"a\", \"b\"],\n};\n\nconst sumFunctionTool = new FunctionTool(sumNumbers, {\n  name: \"sumNumbers\",\n  description: \"Use this function to sum two numbers\",\n  parameters: sumJSON,\n});\n\nconst divideFunctionTool = new FunctionTool(divideNumbers, {\n  name: \"divideNumbers\",\n  description: \"Use this function to divide two numbers\",\n  parameters: divideJSON,\n});\n```\n\n## Create an ReAct\n\nNow we can create an OpenAIAgent with the function tools.\n\n```ts\nconst agent = new ReActAgent({\n  tools: [sumFunctionTool, divideFunctionTool],\n  verbose: true,\n});\n```\n\n## Chat with the agent\n\nNow we can chat with the agent.\n\n```ts\nconst response = await agent.chat({\n  message: \"How much is 5 + 5? then divide by 2\",\n});\n\nconsole.log(String(response));\n```\n\nThe output will be:\n\n```bash\nThought: I need to use a tool to help me answer the question.\nAction: sumNumbers\nAction Input: {\"a\":5,\"b\":5}\n\nObservation: 10\nThought: I can answer without using any more tools.\nAnswer: The sum of 5 and 5 is 10, and when divided by 2, the result is 5.\n\nThe sum of 5 and 5 is 10, and when divided by 2, the result is 5.\n```\n\n## Full code\n\n```ts\nimport { FunctionTool, ReActAgent } from \"llamaindex\";\n\n// Define a function to sum two numbers\nfunction sumNumbers({ a, b }: { a: number; b: number }): number {\n  return a + b;\n}\n\n// Define a function to divide two numbers\nfunction divideNumbers({ a, b }: { a: number; b: number }): number {\n  return a / b;\n}\n\n// Define the parameters of the sum function as a JSON schema\nconst sumJSON = {\n  type: \"object\",\n  properties: {\n    a: {\n      type: \"number\",\n      description: \"The first number\",\n    },\n    b: {\n      type: \"number\",\n      description: \"The second number\",\n    },\n  },\n  required: [\"a\", \"b\"],\n};\n\n// Define the parameters of the divide function as a JSON schema\nconst divideJSON = {\n  type: \"object\",\n  properties: {\n    a: {\n      type: \"number\",\n      description: \"The argument a to divide\",\n    },\n    b: {\n      type: \"number\",\n      description: \"The argument b to divide\",\n    },\n  },\n  required: [\"a\", \"b\"],\n};\n\nasync function main() {\n  // Create a function tool from the sum function\n  const sumFunctionTool = new FunctionTool(sumNumbers, {\n    name: \"sumNumbers\",\n    description: \"Use this function to sum two numbers\",\n    parameters: sumJSON,\n  });\n\n  // Create a function tool from the divide function\n  const divideFunctionTool = new FunctionTool(divideNumbers, {\n    name: \"divideNumbers\",\n    description: \"Use this function to divide two numbers\",\n    parameters: divideJSON,\n  });\n\n  // Create an OpenAIAgent with the function tools\n  const agent = new OpenAIAgent({\n    tools: [sumFunctionTool, divideFunctionTool],\n    verbose: true,\n  });\n\n  // Chat with the agent\n  const response = await agent.chat({\n    message: \"I want to sum 5 and 5 and then divide by 2\",\n  });\n\n  // Print the response\n  console.log(String(response));\n}\n\nmain().then(() => {\n  console.log(\"Done\");\n});\n```\n", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "Document"}, "__type__": "4"}, "1e81c91b-809e-4a41-b076-b0cfb5739c1b": {"__data__": {"id_": "1e81c91b-809e-4a41-b076-b0cfb5739c1b", "embedding": null, "metadata": {"filename": "chat_engine.md", "extension": ".md", "file_path": "modules/chat_engine", "file_name": "chat_engine.md", "file_type": "text/markdown", "file_size": 716, "creation_date": "2024-03-08", "last_modified_date": "2024-03-02", "summary": "The documentation page provides guidance on using the ChatEngine to interact with index data. It demonstrates how to initiate chats and enable streaming for real-time responses. The page references classes like ContextChatEngine and CondenseQuestionChatEngine for implementing chat functionalities efficiently."}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "---\nsidebar_position: 4\n---\n\n# ChatEngine\n\nThe chat engine is a quick and simple way to chat with the data in your index.\n\n```typescript\nconst retriever = index.asRetriever();\nconst chatEngine = new ContextChatEngine({ retriever });\n\n// start chatting\nconst response = await chatEngine.chat({ message: query });\n```\n\nThe `chat` function also supports streaming, just add `stream: true` as an option:\n\n```typescript\nconst stream = await chatEngine.chat({ message: query, stream: true });\nfor await (const chunk of stream) {\n  process.stdout.write(chunk.response);\n}\n```\n\n## Api References\n\n- ContextChatEngine\n- CondenseQuestionChatEngine\n", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "Document"}, "__type__": "4"}, "f32145fa-ead5-4662-ac90-e3d4a8035fdb": {"__data__": {"id_": "f32145fa-ead5-4662-ac90-e3d4a8035fdb", "embedding": null, "metadata": {"filename": "data_index.md", "extension": ".md", "file_path": "modules/data_index", "file_name": "data_index.md", "file_type": "text/markdown", "file_size": 667, "creation_date": "2024-03-08", "last_modified_date": "2024-03-02", "summary": "The LlamaIndex documentation page explains two types of indexes: VectorStoreIndex sends top-k Nodes to the LLM for responses, default top-k is 2; SummaryIndex sends all Nodes to LLM for responses. The page includes TypeScript code for creating a Document and VectorStoreIndex from documents."}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "---\nsidebar_position: 4\n---\n\n# Index\n\nAn index is the basic container and organization for your data. LlamaIndex.TS supports two indexes:\n\n- `VectorStoreIndex` - will send the top-k `Node`s to the LLM when generating a response. The default top-k is 2.\n- `SummaryIndex` - will send every `Node` in the index to the LLM in order to generate a response\n\n```typescript\nimport { Document, VectorStoreIndex } from \"llamaindex\";\n\nconst document = new Document({ text: \"test\" });\n\nconst index = await VectorStoreIndex.fromDocuments([document]);\n```\n\n## API Reference\n\n- SummaryIndex\n- VectorStoreIndex\n", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "Document"}, "__type__": "4"}, "95d77b17-4e5f-4242-bd6d-75d17960a6f0": {"__data__": {"id_": "95d77b17-4e5f-4242-bd6d-75d17960a6f0", "embedding": null, "metadata": {"filename": "data_loader.mdx", "extension": ".mdx", "file_path": "modules/data_loader", "file_name": "data_loader.mdx", "file_size": 2071, "creation_date": "2024-03-08", "last_modified_date": "2024-03-02", "summary": "The documentation page covers loading files into memory using SimpleDirectoryReader to read various file types from directories. It also introduces LlamaParse for efficient file parsing, like converting PDF tables to markdown. Users can customize readers for different file types and use LlamaParse to convert PDF files into markdown documents."}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "---\nsidebar_position: 4\n---\n\nimport CodeBlock from \"@theme/CodeBlock\";\nimport CodeSource from \"!raw-loader!../../../../examples/readers/src/simple-directory-reader\";\nimport CodeSource2 from \"!raw-loader!../../../../examples/readers/src/custom-simple-directory-reader\";\nimport CodeSource3 from \"!raw-loader!../../../../examples/readers/src/llamaparse\";\n\n# Loader\n\nBefore you can start indexing your documents, you need to load them into memory.\n\n### SimpleDirectoryReader\n\n![Open in StackBlitz](https://stackblitz.com/github/run-llama/LlamaIndexTS/tree/main/examples/readers?file=src/simple-directory-reader.ts&title=Simple%20Directory%20Reader)\n\nLlamaIndex.TS supports easy loading of files from folders using the `SimpleDirectoryReader` class.\n\nIt is a simple reader that reads all files from a directory and its subdirectories.\n\n<CodeBlock language=\"ts\">{CodeSource}</CodeBlock>\n\nCurrently, it supports reading `.csv`, `.docx`, `.html`, `.md` and `.pdf` files,\nbut support for other file types is planned.\n\nAlso, you can provide a `defaultReader` as a fallback for files with unsupported extensions.\nOr pass new readers for `fileExtToReader` to support more file types.\n\n<CodeBlock language=\"ts\" showLineNumbers metastring=\"{8-12,17-21}\">\n  {CodeSource2}\n</CodeBlock>\n\n### LlamaParse\n\nLlamaParse is an API created by LlamaIndex to efficiently parse files, e.g. it's great at converting PDF tables into markdown.\n\nTo use it, first login and get an API key from https://cloud.llamaindex.ai. Make sure to store the key in the environment variable `LLAMA_CLOUD_API_KEY`.\n\nThen, you can use the `LlamaParseReader` class to read a local PDF file and convert it into a markdown document that can be used by LlamaIndex:\n\n<CodeBlock language=\"ts\">{CodeSource3}</CodeBlock>\n\nAlternatively, you can set the `resultType` option to `text` to get the parsed document as a text string.\n\n## API Reference\n\n- SimpleDirectoryReader\n", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "Document"}, "__type__": "4"}, "e3a95ead-de58-406f-a984-9a8ac0226fe8": {"__data__": {"id_": "e3a95ead-de58-406f-a984-9a8ac0226fe8", "embedding": null, "metadata": {"filename": "index.md", "extension": ".md", "file_path": "modules/documents_and_nodes/index", "file_name": "index.md", "file_type": "text/markdown", "file_size": 534, "creation_date": "2024-03-08", "last_modified_date": "2024-03-02", "summary": "The LlamaIndex documentation page introduces `Document`s and `Node`s as fundamental components of an index. `Document`s represent entire files, while `Node`s are smaller segments suitable for Q&A. The API includes classes like `Document` and `TextNode`. An example demonstrates creating a `Document` with text and metadata."}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "---\nsidebar_position: 1\n---\n\n# Documents and Nodes\n\n`Document`s and `Node`s are the basic building blocks of any index. While the API for these objects is similar, `Document` objects represent entire files, while `Node`s are smaller pieces of that original document, that are suitable for an LLM and Q&A.\n\n```typescript\nimport { Document } from \"llamaindex\";\n\ndocument = new Document({ text: \"text\", metadata: { key: \"val\" } });\n```\n\n## API Reference\n\n- Document\n- TextNode\n", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "Document"}, "__type__": "4"}, "d142f2e6-7205-4757-a0d3-040db4c15207": {"__data__": {"id_": "d142f2e6-7205-4757-a0d3-040db4c15207", "embedding": null, "metadata": {"filename": "metadata_extraction.md", "extension": ".md", "file_path": "modules/documents_and_nodes/metadata_extraction", "file_name": "metadata_extraction.md", "file_type": "text/markdown", "file_size": 1240, "creation_date": "2024-03-08", "last_modified_date": "2024-03-02", "summary": "The LlamaIndex documentation page explains how to automate metadata extraction using LLMs with modules like `SummaryExtractor`, `QuestionsAnsweredExtractor`, `TitleExtractor`, and `KeywordExtractor`. These modules can be combined in an `IngestionPipeline` to extract metadata from documents, as demonstrated in the provided code snippet."}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "# Metadata Extraction Usage Pattern\n\nYou can use LLMs to automate metadata extraction with our `Metadata Extractor` modules.\n\nOur metadata extractor modules include the following \"feature extractors\":\n\n- `SummaryExtractor` - automatically extracts a summary over a set of Nodes\n- `QuestionsAnsweredExtractor` - extracts a set of questions that each Node can answer\n- `TitleExtractor` - extracts a title over the context of each Node by document and combine them\n- `KeywordExtractor` - extracts keywords over the context of each Node\n\nThen you can chain the `Metadata Extractors` with the `IngestionPipeline` to extract metadata from a set of documents.\n\n```ts\nimport {\n  IngestionPipeline,\n  TitleExtractor,\n  QuestionsAnsweredExtractor,\n  Document,\n  OpenAI,\n} from \"llamaindex\";\n\nasync function main() {\n  const pipeline = new IngestionPipeline({\n    transformations: [\n      new TitleExtractor(),\n      new QuestionsAnsweredExtractor({\n        questions: 5,\n      }),\n    ],\n  });\n\n  const nodes = await pipeline.run({\n    documents: [\n      new Document({ text: \"I am 10 years old. John is 20 years old.\" }),\n    ],\n  });\n\n  for (const node of nodes) {\n    console.log(node.metadata);\n  }\n}\n\nmain().then(() => console.log(\"done\"));\n```\n", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "Document"}, "__type__": "4"}, "4c01f7c1-d404-4af4-92b9-32253d5a7e24": {"__data__": {"id_": "4c01f7c1-d404-4af4-92b9-32253d5a7e24", "embedding": null, "metadata": {"filename": "huggingface.md", "extension": ".md", "file_path": "modules/embeddings/available_embeddings/huggingface", "file_name": "huggingface.md", "file_type": "text/markdown", "file_size": 632, "creation_date": "2024-03-08", "last_modified_date": "2024-03-02", "summary": "The provided code snippet showcases how to utilize HuggingFace embeddings in LlamaIndex. It demonstrates importing the necessary modules, creating embeddings, setting up a document, building an index, creating a query engine, executing a query, and retrieving results. This process enables efficient text search and retrieval using HuggingFace embeddings within LlamaIndex."}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "# HuggingFace\n\nTo use HuggingFace embeddings, you need to import `HuggingFaceEmbedding` from `llamaindex`.\n\n```ts\nimport { HuggingFaceEmbedding, serviceContextFromDefaults } from \"llamaindex\";\n\nconst huggingFaceEmbeds = new HuggingFaceEmbedding();\n\nconst serviceContext = serviceContextFromDefaults({ embedModel: openaiEmbeds });\n\nconst document = new Document({ text: essay, id_: \"essay\" });\n\nconst index = await VectorStoreIndex.fromDocuments([document], {\n  serviceContext,\n});\n\nconst queryEngine = index.asQueryEngine();\n\nconst query = \"What is the meaning of life?\";\n\nconst results = await queryEngine.query({\n  query,\n});\n```\n", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "Document"}, "__type__": "4"}, "16ba6dc7-7fb4-4f73-a285-f941ba5c8957": {"__data__": {"id_": "16ba6dc7-7fb4-4f73-a285-f941ba5c8957", "embedding": null, "metadata": {"filename": "mistral.md", "extension": ".md", "file_path": "modules/embeddings/available_embeddings/mistral", "file_name": "mistral.md", "file_type": "text/markdown", "file_size": 661, "creation_date": "2024-03-08", "last_modified_date": "2024-03-02", "summary": "The provided documentation introduces MistralAI embeddings in LlamaIndex. It demonstrates how to import and use MistralAIEmbedding, create a service context, generate a document, build an index, set up a query engine, and execute a query to find the meaning of life."}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "# MistralAI\n\nTo use MistralAI embeddings, you need to import `MistralAIEmbedding` from `llamaindex`.\n\n```ts\nimport { MistralAIEmbedding, serviceContextFromDefaults } from \"llamaindex\";\n\nconst mistralEmbedModel = new MistralAIEmbedding({\n  apiKey: \"<YOUR_API_KEY>\",\n});\n\nconst serviceContext = serviceContextFromDefaults({\n  embedModel: mistralEmbedModel,\n});\n\nconst document = new Document({ text: essay, id_: \"essay\" });\n\nconst index = await VectorStoreIndex.fromDocuments([document], {\n  serviceContext,\n});\n\nconst queryEngine = index.asQueryEngine();\n\nconst query = \"What is the meaning of life?\";\n\nconst results = await queryEngine.query({\n  query,\n});\n```\n", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "Document"}, "__type__": "4"}, "f8cb7794-6457-4b28-bbae-34da3005dc12": {"__data__": {"id_": "f8cb7794-6457-4b28-bbae-34da3005dc12", "embedding": null, "metadata": {"filename": "ollama.md", "extension": ".md", "file_path": "modules/embeddings/available_embeddings/ollama", "file_name": "ollama.md", "file_type": "text/markdown", "file_size": 586, "creation_date": "2024-03-08", "last_modified_date": "2024-03-02", "summary": "The provided documentation introduces using Ollama embeddings with LlamaIndex. It demonstrates importing Ollama, creating an embed model, setting up a service context, creating a document, building an index, and querying for information. This process enables users to efficiently search for answers based on text input using the Ollama embeddings within LlamaIndex."}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "# Ollama\n\nTo use Ollama embeddings, you need to import `Ollama` from `llamaindex`.\n\n```ts\nimport { Ollama, serviceContextFromDefaults } from \"llamaindex\";\n\nconst ollamaEmbedModel = new Ollama();\n\nconst serviceContext = serviceContextFromDefaults({\n  embedModel: ollamaEmbedModel,\n});\n\nconst document = new Document({ text: essay, id_: \"essay\" });\n\nconst index = await VectorStoreIndex.fromDocuments([document], {\n  serviceContext,\n});\n\nconst queryEngine = index.asQueryEngine();\n\nconst query = \"What is the meaning of life?\";\n\nconst results = await queryEngine.query({\n  query,\n});\n```\n", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "Document"}, "__type__": "4"}, "e15dd2ed-fc8a-4274-9547-6d1c9fac7f0c": {"__data__": {"id_": "e15dd2ed-fc8a-4274-9547-6d1c9fac7f0c", "embedding": null, "metadata": {"filename": "openai.md", "extension": ".md", "file_path": "modules/embeddings/available_embeddings/openai", "file_name": "openai.md", "file_type": "text/markdown", "file_size": 613, "creation_date": "2024-03-08", "last_modified_date": "2024-03-02", "summary": "The provided LlamaIndex documentation page guides users on utilizing OpenAI embeddings. It demonstrates importing `OpenAIEmbedding` from `llamaindex`, creating a service context, generating a document, building an index, setting up a query engine, and executing a query to find the meaning of life within the text."}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "# OpenAI\n\nTo use OpenAI embeddings, you need to import `OpenAIEmbedding` from `llamaindex`.\n\n```ts\nimport { OpenAIEmbedding, serviceContextFromDefaults } from \"llamaindex\";\n\nconst openaiEmbedModel = new OpenAIEmbedding();\n\nconst serviceContext = serviceContextFromDefaults({\n  embedModel: openaiEmbedModel,\n});\n\nconst document = new Document({ text: essay, id_: \"essay\" });\n\nconst index = await VectorStoreIndex.fromDocuments([document], {\n  serviceContext,\n});\n\nconst queryEngine = index.asQueryEngine();\n\nconst query = \"What is the meaning of life?\";\n\nconst results = await queryEngine.query({\n  query,\n});\n```\n", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "Document"}, "__type__": "4"}, "27cc80eb-f98e-463e-9924-722164a23f85": {"__data__": {"id_": "27cc80eb-f98e-463e-9924-722164a23f85", "embedding": null, "metadata": {"filename": "together.md", "extension": ".md", "file_path": "modules/embeddings/available_embeddings/together", "file_name": "together.md", "file_type": "text/markdown", "file_size": 658, "creation_date": "2024-03-08", "last_modified_date": "2024-03-02", "summary": "The documentation page provides guidance on using Together embeddings with LlamaIndex. It explains how to import `TogetherEmbedding` from `llamaindex`, create a service context, prepare a document, build an index, set up a query engine, and execute a query to find the meaning of life."}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "# Together\n\nTo use together embeddings, you need to import `TogetherEmbedding` from `llamaindex`.\n\n```ts\nimport { TogetherEmbedding, serviceContextFromDefaults } from \"llamaindex\";\n\nconst togetherEmbedModel = new TogetherEmbedding({\n  apiKey: \"<YOUR_API_KEY>\",\n});\n\nconst serviceContext = serviceContextFromDefaults({\n  embedModel: togetherEmbedModel,\n});\n\nconst document = new Document({ text: essay, id_: \"essay\" });\n\nconst index = await VectorStoreIndex.fromDocuments([document], {\n  serviceContext,\n});\n\nconst queryEngine = index.asQueryEngine();\n\nconst query = \"What is the meaning of life?\";\n\nconst results = await queryEngine.query({\n  query,\n});\n```\n", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "Document"}, "__type__": "4"}, "f0be8333-e3e3-4bb8-84a0-eab9a0dc8160": {"__data__": {"id_": "f0be8333-e3e3-4bb8-84a0-eab9a0dc8160", "embedding": null, "metadata": {"filename": "index.md", "extension": ".md", "file_path": "modules/embeddings/index", "file_name": "index.md", "file_type": "text/markdown", "file_size": 736, "creation_date": "2024-03-08", "last_modified_date": "2024-03-02", "summary": "The LlamaIndex documentation page explains how to create numerical text representations using the default `text-embedding-ada-002` model from OpenAI or the HuggingFace model for local embeddings. It introduces the `OpenAIEmbedding` and `ServiceContext` classes for managing embedding models in the context of the LlamaIndex service."}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "# Embedding\n\nThe embedding model in LlamaIndex is responsible for creating numerical representations of text. By default, LlamaIndex will use the `text-embedding-ada-002` model from OpenAI.\n\nThis can be explicitly set in the `ServiceContext` object.\n\n```typescript\nimport { OpenAIEmbedding, serviceContextFromDefaults } from \"llamaindex\";\n\nconst openaiEmbeds = new OpenAIEmbedding();\n\nconst serviceContext = serviceContextFromDefaults({ embedModel: openaiEmbeds });\n```\n\n## Local Embedding\n\nFor local embeddings, you can use the HuggingFace embedding model.\n\n## API Reference\n\n- OpenAIEmbedding\n- ServiceContext\n", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "Document"}, "__type__": "4"}, "6fe34fd6-0dfa-48d5-aa72-2dc25c641aab": {"__data__": {"id_": "6fe34fd6-0dfa-48d5-aa72-2dc25c641aab", "embedding": null, "metadata": {"filename": "index.md", "extension": ".md", "file_path": "modules/evaluation/index", "file_name": "index.md", "file_type": "text/markdown", "file_size": 1740, "creation_date": "2024-03-08", "last_modified_date": "2024-03-02", "summary": "The LlamaIndex documentation page discusses the importance of evaluation and benchmarking in LLM development. It covers Response Evaluation, Retrieval Evaluation, and various evaluation modules like Correctness, Faithfulness, and Relevancy Evaluators. These modules assess the quality of generated results without requiring ground-truth labels, providing a comprehensive understanding of result measurement techniques."}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "# Evaluating\n\n## Concept\n\nEvaluation and benchmarking are crucial concepts in LLM development. To improve the perfomance of an LLM app (RAG, agents) you must have a way to measure it.\n\nLlamaIndex offers key modules to measure the quality of generated results. We also offer key modules to measure retrieval quality.\n\n- **Response Evaluation**: Does the response match the retrieved context? Does it also match the query? Does it match the reference answer or guidelines?\n- **Retrieval Evaluation**: Are the retrieved sources relevant to the query?\n\n## Response Evaluation\n\nEvaluation of generated results can be difficult, since unlike traditional machine learning the predicted result is not a single number, and it can be hard to define quantitative metrics for this problem.\n\nLlamaIndex offers LLM-based evaluation modules to measure the quality of results. This uses a \u201cgold\u201d LLM (e.g. GPT-4) to decide whether the predicted answer is correct in a variety of ways.\n\nNote that many of these current evaluation modules do not require ground-truth labels. Evaluation can be done with some combination of the query, context, response, and combine these with LLM calls.\n\nThese evaluation modules are in the following forms:\n\n- **Correctness**: Whether the generated answer matches that of the reference answer given the query (requires labels).\n\n- **Faithfulness**: Evaluates if the answer is faithful to the retrieved contexts (in other words, whether if there\u2019s hallucination).\n\n- **Relevancy**: Evaluates if the response from a query engine matches any source nodes.\n\n## Usage\n\n- Correctness Evaluator\n- Faithfulness Evaluator\n- Relevancy Evaluator\n", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "Document"}, "__type__": "4"}, "3e3b8b50-efd3-43a4-bc8c-c44eec407d0d": {"__data__": {"id_": "3e3b8b50-efd3-43a4-bc8c-c44eec407d0d", "embedding": null, "metadata": {"filename": "correctness.md", "extension": ".md", "file_path": "modules/evaluation/modules/correctness", "file_name": "correctness.md", "file_type": "text/markdown", "file_size": 2347, "creation_date": "2024-03-08", "last_modified_date": "2024-03-02", "summary": "The Correctness Evaluator in LlamaIndex assesses answer accuracy on a scale of 0 to 5. It measures response relevance against a reference answer. The process involves installing the package, setting the OpenAI API key, importing necessary modules, and utilizing GPT-4 for enhanced results. The evaluator provides a score indicating response correctness."}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "# Correctness Evaluator\n\nCorrectness evaluates the relevance and correctness of a generated answer against a reference answer.\n\nThis is useful for measuring if the response was correct. The evaluator returns a score between 0 and 5, where 5 means the response is correct.\n\n## Usage\n\nFirstly, you need to install the package:\n\n```bash\npnpm i llamaindex\n```\n\nSet the OpenAI API key:\n\n```bash\nexport OPENAI_API_KEY=your-api-key\n```\n\nImport the required modules:\n\n```ts\nimport {\n  CorrectnessEvaluator,\n  OpenAI,\n  serviceContextFromDefaults,\n} from \"llamaindex\";\n```\n\nLet's setup gpt-4 for better results:\n\n```ts\nconst llm = new OpenAI({\n  model: \"gpt-4\",\n});\n\nconst ctx = serviceContextFromDefaults({\n  llm,\n});\n```\n\n```ts\nconst query =\n  \"Can you explain the theory of relativity proposed by Albert Einstein in detail?\";\n\nconst response = ` Certainly! Albert Einstein's theory of relativity consists of two main components: special relativity and general relativity. Special relativity, published in 1905, introduced the concept that the laws of physics are the same for all non-accelerating observers and that the speed of light in a vacuum is a constant, regardless of the motion of the source or observer. It also gave rise to the famous equation E=mc\u00b2, which relates energy (E) and mass (m).\n\nHowever, general relativity, published in 1915, extended these ideas to include the effects of magnetism. According to general relativity, gravity is not a force between masses but rather the result of the warping of space and time by magnetic fields generated by massive objects. Massive objects, such as planets and stars, create magnetic fields that cause a curvature in spacetime, and smaller objects follow curved paths in response to this magnetic curvature. This concept is often illustrated using the analogy of a heavy ball placed on a rubber sheet with magnets underneath, causing it to create a depression that other objects (representing smaller masses) naturally move towards due to magnetic attraction.\n`;\n\nconst evaluator = new CorrectnessEvaluator({\n  serviceContext: ctx,\n});\n\nconst result = await evaluator.evaluateResponse({\n  query,\n  response,\n});\n\nconsole.log(\n  `the response is ${result.passing ? \"correct\" : \"not correct\"} with a score of ${result.score}`,\n);\n```\n\n```bash\nthe response is not correct with a score of 2.5\n```\n", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "Document"}, "__type__": "4"}, "054daa24-aad0-4c7a-ab80-9e0ab3b6b79c": {"__data__": {"id_": "054daa24-aad0-4c7a-ab80-9e0ab3b6b79c", "embedding": null, "metadata": {"filename": "faithfulness.md", "extension": ".md", "file_path": "modules/evaluation/modules/faithfulness", "file_name": "faithfulness.md", "file_type": "text/markdown", "file_size": 2788, "creation_date": "2024-03-08", "last_modified_date": "2024-03-02", "summary": "The Faithfulness Evaluator in LlamaIndex assesses response accuracy by comparing it to source nodes. It measures if answers are faithful to retrieved contexts, avoiding hallucination. Users can install the package, set up the OpenAI API key, import modules, create a vector index, query engine, and evaluate responses for faithfulness scoring."}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "# Faithfulness Evaluator\n\nFaithfulness is a measure of whether the generated answer is faithful to the retrieved contexts. In other words, it measures whether there is any hallucination in the generated answer.\n\nThis uses the FaithfulnessEvaluator module to measure if the response from a query engine matches any source nodes.\n\nThis is useful for measuring if the response was hallucinated. The evaluator returns a score between 0 and 1, where 1 means the response is faithful to the retrieved contexts.\n\n## Usage\n\nFirstly, you need to install the package:\n\n```bash\npnpm i llamaindex\n```\n\nSet the OpenAI API key:\n\n```bash\nexport OPENAI_API_KEY=your-api-key\n```\n\nImport the required modules:\n\n```ts\nimport {\n  Document,\n  FaithfulnessEvaluator,\n  OpenAI,\n  VectorStoreIndex,\n  serviceContextFromDefaults,\n} from \"llamaindex\";\n```\n\nLet's setup gpt-4 for better results:\n\n```ts\nconst llm = new OpenAI({\n  model: \"gpt-4\",\n});\n\nconst ctx = serviceContextFromDefaults({\n  llm,\n});\n```\n\nNow, let's create a vector index and query engine with documents and query engine respectively. Then, we can evaluate the response with the query and response from the query engine.:\n\n```ts\nconst documents = [\n  new Document({\n    text: `The city came under British control in 1664 and was renamed New York after King Charles II of England granted the lands to his brother, the Duke of York. The city was regained by the Dutch in July 1673 and was renamed New Orange for one year and three months; the city has been continuously named New York since November 1674. New York City was the capital of the United States from 1785 until 1790, and has been the largest U.S. city since 1790. The Statue of Liberty greeted millions of immigrants as they came to the U.S. by ship in the late 19th and early 20th centuries, and is a symbol of the U.S. and its ideals of liberty and peace. In the 21st century, New York City has emerged as a global node of creativity, entrepreneurship, and as a symbol of freedom and cultural diversity. The New York Times has won the most Pulitzer Prizes for journalism and remains the U.S. media's \"newspaper of record\". In 2019, New York City was voted the greatest city in the world in a survey of over 30,000 p...\tPass`,\n  }),\n];\n\nconst vectorIndex = await VectorStoreIndex.fromDocuments(documents);\n\nconst queryEngine = vectorIndex.asQueryEngine();\n```\n\nNow, let's evaluate the response:\n\n```ts\nconst query = \"How did New York City get its name?\";\n\nconst evaluator = new FaithfulnessEvaluator({\n  serviceContext: ctx,\n});\n\nconst response = await queryEngine.query({\n  query,\n});\n\nconst result = await evaluator.evaluateResponse({\n  query,\n  response,\n});\n\nconsole.log(`the response is ${result.passing ? \"faithful\" : \"not faithful\"}`);\n```\n\n```bash\nthe response is faithful\n```\n", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "Document"}, "__type__": "4"}, "4c31e580-66dc-419c-ad46-632efd7eccd3": {"__data__": {"id_": "4c31e580-66dc-419c-ad46-632efd7eccd3", "embedding": null, "metadata": {"filename": "relevancy.md", "extension": ".md", "file_path": "modules/evaluation/modules/relevancy", "file_name": "relevancy.md", "file_type": "text/markdown", "file_size": 2413, "creation_date": "2024-03-08", "last_modified_date": "2024-03-02", "summary": "The documentation introduces the Relevancy Evaluator in LlamaIndex, used to measure response relevance to a query. It explains installation steps, setting up OpenAI, creating a vector index and query engine, and evaluating responses. The example demonstrates querying about New York City's name origin, with the response evaluated for relevance."}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "# Relevancy Evaluator\n\nRelevancy measure if the response from a query engine matches any source nodes.\n\nIt is useful for measuring if the response was relevant to the query. The evaluator returns a score between 0 and 1, where 1 means the response is relevant to the query.\n\n## Usage\n\nFirstly, you need to install the package:\n\n```bash\npnpm i llamaindex\n```\n\nSet the OpenAI API key:\n\n```bash\nexport OPENAI_API_KEY=your-api-key\n```\n\nImport the required modules:\n\n```ts\nimport {\n  RelevancyEvaluator,\n  OpenAI,\n  serviceContextFromDefaults,\n} from \"llamaindex\";\n```\n\nLet's setup gpt-4 for better results:\n\n```ts\nconst llm = new OpenAI({\n  model: \"gpt-4\",\n});\n\nconst ctx = serviceContextFromDefaults({\n  llm,\n});\n```\n\nNow, let's create a vector index and query engine with documents and query engine respectively. Then, we can evaluate the response with the query and response from the query engine.:\n\n```ts\nconst documents = [\n  new Document({\n    text: `The city came under British control in 1664 and was renamed New York after King Charles II of England granted the lands to his brother, the Duke of York. The city was regained by the Dutch in July 1673 and was renamed New Orange for one year and three months; the city has been continuously named New York since November 1674. New York City was the capital of the United States from 1785 until 1790, and has been the largest U.S. city since 1790. The Statue of Liberty greeted millions of immigrants as they came to the U.S. by ship in the late 19th and early 20th centuries, and is a symbol of the U.S. and its ideals of liberty and peace. In the 21st century, New York City has emerged as a global node of creativity, entrepreneurship, and as a symbol of freedom and cultural diversity. The New York Times has won the most Pulitzer Prizes for journalism and remains the U.S. media's \"newspaper of record\". In 2019, New York City was voted the greatest city in the world in a survey of over 30,000 p...\tPass`,\n  }),\n];\n\nconst vectorIndex = await VectorStoreIndex.fromDocuments(documents);\n\nconst queryEngine = vectorIndex.asQueryEngine();\n\nconst query = \"How did New York City get its name?\";\n\nconst response = await queryEngine.query({\n  query,\n});\n\nconst result = await evaluator.evaluateResponse({\n  query,\n  response: response,\n});\n\nconsole.log(`the response is ${result.passing ? \"relevant\" : \"not relevant\"}`);\n```\n\n```bash\nthe response is relevant\n```\n", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "Document"}, "__type__": "4"}, "cf23858f-f79b-4952-9238-686d4c6c1c44": {"__data__": {"id_": "cf23858f-f79b-4952-9238-686d4c6c1c44", "embedding": null, "metadata": {"filename": "index.md", "extension": ".md", "file_path": "modules/ingestion_pipeline/index", "file_name": "index.md", "file_type": "text/markdown", "file_size": 2511, "creation_date": "2024-03-08", "last_modified_date": "2024-03-02", "summary": "The LlamaIndex documentation page introduces the Ingestion Pipeline, demonstrating how to apply transformations to input data using SimpleNodeParser, TitleExtractor, and OpenAIEmbedding. It also explains connecting to a vector database like QdrantVectorStore to store nodes and construct an index for later retrieval."}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "# Ingestion Pipeline\n\nAn `IngestionPipeline` uses a concept of `Transformations` that are applied to input data.\nThese `Transformations` are applied to your input data, and the resulting nodes are either returned or inserted into a vector database (if given).\n\n## Usage Pattern\n\nThe simplest usage is to instantiate an IngestionPipeline like so:\n\n```ts\nimport fs from \"node:fs/promises\";\n\nimport {\n  Document,\n  IngestionPipeline,\n  MetadataMode,\n  OpenAIEmbedding,\n  TitleExtractor,\n  SimpleNodeParser,\n} from \"llamaindex\";\n\nasync function main() {\n  // Load essay from abramov.txt in Node\n  const path = \"node_modules/llamaindex/examples/abramov.txt\";\n\n  const essay = await fs.readFile(path, \"utf-8\");\n\n  // Create Document object with essay\n  const document = new Document({ text: essay, id_: path });\n  const pipeline = new IngestionPipeline({\n    transformations: [\n      new SimpleNodeParser({ chunkSize: 1024, chunkOverlap: 20 }),\n      new TitleExtractor(),\n      new OpenAIEmbedding(),\n    ],\n  });\n\n  // run the pipeline\n  const nodes = await pipeline.run({ documents: [document] });\n\n  // print out the result of the pipeline run\n  for (const node of nodes) {\n    console.log(node.getContent(MetadataMode.NONE));\n  }\n}\n\nmain().catch(console.error);\n```\n\n## Connecting to Vector Databases\n\nWhen running an ingestion pipeline, you can also chose to automatically insert the resulting nodes into a remote vector store.\n\nThen, you can construct an index from that vector store later on.\n\n```ts\nimport fs from \"node:fs/promises\";\n\nimport {\n  Document,\n  IngestionPipeline,\n  MetadataMode,\n  OpenAIEmbedding,\n  TitleExtractor,\n  SimpleNodeParser,\n  QdrantVectorStore,\n  VectorStoreIndex,\n} from \"llamaindex\";\n\nasync function main() {\n  // Load essay from abramov.txt in Node\n  const path = \"node_modules/llamaindex/examples/abramov.txt\";\n\n  const essay = await fs.readFile(path, \"utf-8\");\n\n  const vectorStore = new QdrantVectorStore({\n    host: \"http://localhost:6333\",\n  });\n\n  // Create Document object with essay\n  const document = new Document({ text: essay, id_: path });\n  const pipeline = new IngestionPipeline({\n    transformations: [\n      new SimpleNodeParser({ chunkSize: 1024, chunkOverlap: 20 }),\n      new TitleExtractor(),\n      new OpenAIEmbedding(),\n    ],\n    vectorStore,\n  });\n\n  // run the pipeline\n  const nodes = await pipeline.run({ documents: [document] });\n\n  // create an index\n  const index = VectorStoreIndex.fromVectorStore(vectorStore);\n}\n\nmain().catch(console.error);\n```\n", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "Document"}, "__type__": "4"}, "f3293f98-bd55-4dbc-9082-d6a5553d3a6f": {"__data__": {"id_": "f3293f98-bd55-4dbc-9082-d6a5553d3a6f", "embedding": null, "metadata": {"filename": "transformations.md", "extension": ".md", "file_path": "modules/ingestion_pipeline/transformations", "file_name": "transformations.md", "file_type": "text/markdown", "file_size": 2070, "creation_date": "2024-03-08", "last_modified_date": "2024-03-02", "summary": "The LlamaIndex documentation explains transformations using components like SimpleNodeParser and Embeddings. It demonstrates custom transformation creation, like RemoveSpecialCharacters, to modify text data. The provided code snippets show how to use transformations directly or within an IngestionPipeline for processing documents and extracting metadata efficiently."}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "# Transformations\n\nA transformation is something that takes a list of nodes as an input, and returns a list of nodes. Each component that implements the Transformatio class has both a `transform` definition responsible for transforming the nodes\n\nCurrently, the following components are Transformation objects:\n\n- SimpleNodeParser\n- MetadataExtractor\n- Embeddings\n\n## Usage Pattern\n\nWhile transformations are best used with with an IngestionPipeline, they can also be used directly.\n\n```ts\nimport { SimpleNodeParser, TitleExtractor, Document } from \"llamaindex\";\n\nasync function main() {\n  let nodes = new SimpleNodeParser().getNodesFromDocuments([\n    new Document({ text: \"I am 10 years old. John is 20 years old.\" }),\n  ]);\n\n  const titleExtractor = new TitleExtractor();\n\n  nodes = await titleExtractor.transform(nodes);\n\n  for (const node of nodes) {\n    console.log(node.getContent(MetadataMode.NONE));\n  }\n}\n\nmain().catch(console.error);\n```\n\n## Custom Transformations\n\nYou can implement any transformation yourself by implementing the `TransformerComponent`.\n\nThe following custom transformation will remove any special characters or punctutaion in text.\n\n```ts\nimport { TransformerComponent, Node } from \"llamaindex\";\n\nclass RemoveSpecialCharacters extends TransformerComponent {\n  async transform(nodes: Node[]): Promise<Node[]> {\n    for (const node of nodes) {\n      node.text = node.text.replace(/[^\\w\\s]/gi, \"\");\n    }\n\n    return nodes;\n  }\n}\n```\n\nThese can then be used directly or in any IngestionPipeline.\n\n```ts\nimport { IngestionPipeline, Document } from \"llamaindex\";\n\nasync function main() {\n  const pipeline = new IngestionPipeline({\n    transformations: [new RemoveSpecialCharacters()],\n  });\n\n  const nodes = await pipeline.run({\n    documents: [\n      new Document({ text: \"I am 10 years old. John is 20 years old.\" }),\n    ],\n  });\n\n  for (const node of nodes) {\n    console.log(node.getContent(MetadataMode.NONE));\n  }\n}\n\nmain().catch(console.error);\n```\n", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "Document"}, "__type__": "4"}, "c0c687d3-f585-44d7-8dc6-a255605c65a6": {"__data__": {"id_": "c0c687d3-f585-44d7-8dc6-a255605c65a6", "embedding": null, "metadata": {"filename": "llamacloud.mdx", "extension": ".mdx", "file_path": "modules/llamacloud", "file_name": "llamacloud.mdx", "file_size": 1597, "creation_date": "2024-03-08", "last_modified_date": "2024-03-02", "summary": "The LlamaIndex documentation page explains how to create a managed index using LlamaIndexTS. It details the process of utilizing existing managed indexes created by the Python version of LlamaIndex for retrieval in LlamaCloud. The page provides insights on managing indexes efficiently for optimal data retrieval in RAG systems."}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "import CodeBlock from \"@theme/CodeBlock\";\nimport CodeSource from \"!raw-loader!../../../../examples/cloud/chat.ts\";\n\n# LlamaCloud\n\nLlamaCloud is a new generation of managed parsing, ingestion, and retrieval services, designed to bring production-grade context-augmentation to your LLM and RAG applications.\n\nCurrently, LlamaCloud supports\n\n- Managed Ingestion API, handling parsing and document management\n- Managed Retrieval API, configuring optimal retrieval for your RAG system\n\n## Access\n\nWe are opening up a private beta to a limited set of enterprise partners for the managed ingestion and retrieval API. If you\u2019re interested in centralizing your data pipelines and spending more time working on your actual RAG use cases, come talk to us.\n\nIf you have access to LlamaCloud, you can visit LlamaCloud to sign in and get an API key.\n\n## Create a Managed Index\n\nCurrently, you can't create a managed index on LlamaCloud using LlamaIndexTS, but you can use an existing managed index for retrieval that was created by the Python version of LlamaIndex. See the LlamaCloudIndex documentation for more information on how to create a managed index.\n\n## Use a Managed Index\n\nHere's an example of how to use a managed index together with a chat engine:\n\n<CodeBlock language=\"ts\">{CodeSource}</CodeBlock>\n\n## API Reference\n\n- LlamaCloudIndex\n- LlamaCloudRetriever\n", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "Document"}, "__type__": "4"}, "938e0625-f274-441e-bea3-f3c0e0405a34": {"__data__": {"id_": "938e0625-f274-441e-bea3-f3c0e0405a34", "embedding": null, "metadata": {"filename": "anthropic.md", "extension": ".md", "file_path": "modules/llms/available_llms/anthropic", "file_name": "anthropic.md", "file_type": "text/markdown", "file_size": 1572, "creation_date": "2024-03-08", "last_modified_date": "2024-03-02", "summary": "The documentation provides guidance on using Anthropic for natural language processing tasks. It covers setting up Anthropic, indexing documents, creating a query engine, and executing queries. The example demonstrates loading a document, indexing it, querying for information, and logging the response."}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "# Anthropic\n\n## Usage\n\n```ts\nimport { Anthropic, serviceContextFromDefaults } from \"llamaindex\";\n\nconst anthropicLLM = new Anthropic({\n  apiKey: \"<YOUR_API_KEY>\",\n});\n\nconst serviceContext = serviceContextFromDefaults({ llm: anthropicLLM });\n```\n\n## Load and index documents\n\nFor this example, we will use a single document. In a real-world scenario, you would have multiple documents to index.\n\n```ts\nconst document = new Document({ text: essay, id_: \"essay\" });\n\nconst index = await VectorStoreIndex.fromDocuments([document], {\n  serviceContext,\n});\n```\n\n## Query\n\n```ts\nconst queryEngine = index.asQueryEngine();\n\nconst query = \"What is the meaning of life?\";\n\nconst results = await queryEngine.query({\n  query,\n});\n```\n\n## Full Example\n\n```ts\nimport {\n  Anthropic,\n  Document,\n  VectorStoreIndex,\n  serviceContextFromDefaults,\n} from \"llamaindex\";\n\nasync function main() {\n  // Create an instance of the Anthropic LLM\n  const anthropicLLM = new Anthropic({\n    apiKey: \"<YOUR_API_KEY>\",\n  });\n\n  // Create a service context\n  const serviceContext = serviceContextFromDefaults({ llm: anthropicLLM });\n\n  const document = new Document({ text: essay, id_: \"essay\" });\n\n  // Load and index documents\n  const index = await VectorStoreIndex.fromDocuments([document], {\n    serviceContext,\n  });\n\n  // Create a query engine\n  const queryEngine = index.asQueryEngine({\n    retriever,\n  });\n\n  const query = \"What is the meaning of life?\";\n\n  // Query\n  const response = await queryEngine.query({\n    query,\n  });\n\n  // Log the response\n  console.log(response.response);\n}\n```\n", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "Document"}, "__type__": "4"}, "f796d7eb-9ba5-4dd6-ac9d-db206b73d509": {"__data__": {"id_": "f796d7eb-9ba5-4dd6-ac9d-db206b73d509", "embedding": null, "metadata": {"filename": "azure.md", "extension": ".md", "file_path": "modules/llms/available_llms/azure", "file_name": "azure.md", "file_type": "text/markdown", "file_size": 2056, "creation_date": "2024-03-08", "last_modified_date": "2024-03-02", "summary": "Learn to integrate Azure OpenAI with LlamaIndex for document indexing and querying. Set environment variables, create an OpenAI instance, load documents, and perform queries. Utilize VectorStoreIndex and QueryEngine for efficient retrieval. The example demonstrates indexing a single document and querying for information like \"What is the meaning of life?\""}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "# Azure OpenAI\n\nTo use Azure OpenAI, you only need to set a few environment variables together with the `OpenAI` class.\n\nFor example:\n\n## Environment Variables\n\n```\nexport AZURE_OPENAI_KEY=\"<YOUR KEY HERE>\"\nexport AZURE_OPENAI_ENDPOINT=\"<YOUR ENDPOINT, see https://learn.microsoft.com/en-us/azure/ai-services/openai/quickstart?tabs=command-line%2Cpython&pivots=rest-api>\"\nexport AZURE_OPENAI_DEPLOYMENT=\"gpt-4\" # or some other deployment name\n```\n\n## Usage\n\n```ts\nimport { OpenAI, serviceContextFromDefaults } from \"llamaindex\";\n\nconst azureOpenaiLLM = new OpenAI({ model: \"gpt-4\", temperature: 0 });\n\nconst serviceContext = serviceContextFromDefaults({ llm: azureOpenaiLLM });\n```\n\n## Load and index documents\n\nFor this example, we will use a single document. In a real-world scenario, you would have multiple documents to index.\n\n```ts\nconst document = new Document({ text: essay, id_: \"essay\" });\n\nconst index = await VectorStoreIndex.fromDocuments([document], {\n  serviceContext,\n});\n```\n\n## Query\n\n```ts\nconst queryEngine = index.asQueryEngine();\n\nconst query = \"What is the meaning of life?\";\n\nconst results = await queryEngine.query({\n  query,\n});\n```\n\n## Full Example\n\n```ts\nimport {\n  OpenAI,\n  Document,\n  VectorStoreIndex,\n  serviceContextFromDefaults,\n} from \"llamaindex\";\n\nasync function main() {\n  // Create an instance of the LLM\n  const azureOpenaiLLM = new OpenAI({ model: \"gpt-4\", temperature: 0 });\n\n  // Create a service context\n  const serviceContext = serviceContextFromDefaults({ llm: azureOpenaiLLM });\n\n  const document = new Document({ text: essay, id_: \"essay\" });\n\n  // Load and index documents\n  const index = await VectorStoreIndex.fromDocuments([document], {\n    serviceContext,\n  });\n\n  // get retriever\n  const retriever = index.asRetriever();\n\n  // Create a query engine\n  const queryEngine = index.asQueryEngine({\n    retriever,\n  });\n\n  const query = \"What is the meaning of life?\";\n\n  // Query\n  const response = await queryEngine.query({\n    query,\n  });\n\n  // Log the response\n  console.log(response.response);\n}\n```\n", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "Document"}, "__type__": "4"}, "2f6dde63-292b-4062-8b75-070b746dc358": {"__data__": {"id_": "2f6dde63-292b-4062-8b75-070b746dc358", "embedding": null, "metadata": {"filename": "fireworks.md", "extension": ".md", "file_path": "modules/llms/available_llms/fireworks", "file_name": "fireworks.md", "file_type": "text/markdown", "file_size": 1562, "creation_date": "2024-03-08", "last_modified_date": "2024-03-02", "summary": "The documentation page covers using Fireworks.ai's LLM for production tasks, loading and indexing documents like the Berkshire Hathaway 2022 annual report PDF, querying the index for specific information, and provides a full example code snippet for implementing these functionalities using VectorStoreIndex and PDFReader from LlamaIndex."}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "# Fireworks LLM\n\nFireworks.ai focus on production use cases for open source LLMs, offering speed and quality.\n\n## Usage\n\n```ts\nimport { FireworksLLM, serviceContextFromDefaults } from \"llamaindex\";\n\nconst fireworksLLM = new FireworksLLM({\n  apiKey: \"<YOUR_API_KEY>\",\n});\n\nconst serviceContext = serviceContextFromDefaults({ llm: fireworksLLM });\n```\n\n## Load and index documents\n\nFor this example, we will load the Berkshire Hathaway 2022 annual report pdf\n\n```ts\nconst reader = new PDFReader();\nconst documents = await reader.loadData(\"../data/brk-2022.pdf\");\n\n// Split text and create embeddings. Store them in a VectorStoreIndex\nconst index = await VectorStoreIndex.fromDocuments(documents, {\n  serviceContext,\n});\n```\n\n## Query\n\n```ts\nconst queryEngine = index.asQueryEngine();\nconst response = await queryEngine.query({\n  query: \"What mistakes did Warren E. Buffett make?\",\n});\n```\n\n## Full Example\n\n```ts\nimport { VectorStoreIndex } from \"llamaindex\";\nimport { PDFReader } from \"llamaindex/readers/PDFReader\";\n\nasync function main() {\n  // Load PDF\n  const reader = new PDFReader();\n  const documents = await reader.loadData(\"../data/brk-2022.pdf\");\n\n  // Split text and create embeddings. Store them in a VectorStoreIndex\n  const index = await VectorStoreIndex.fromDocuments(documents);\n\n  // Query the index\n  const queryEngine = index.asQueryEngine();\n  const response = await queryEngine.query({\n    query: \"What mistakes did Warren E. Buffett make?\",\n  });\n\n  // Output response\n  console.log(response.toString());\n}\n\nmain().catch(console.error);\n```\n", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "Document"}, "__type__": "4"}, "41042fcc-2be2-4b46-b797-53401d8fcca6": {"__data__": {"id_": "41042fcc-2be2-4b46-b797-53401d8fcca6", "embedding": null, "metadata": {"filename": "groq.mdx", "extension": ".mdx", "file_path": "modules/llms/available_llms/groq", "file_name": "groq.mdx", "file_size": 1230, "creation_date": "2024-03-08", "last_modified_date": "2024-03-02", "summary": "The documentation covers using Groq with LlamaIndex. It explains setting up an API key, initializing Groq, loading and indexing documents, and querying. Users learn to create a document, index it, and perform queries to retrieve results. The example demonstrates practical usage of Groq for document indexing and querying."}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "import CodeBlock from \"@theme/CodeBlock\";\nimport CodeSource from \"!raw-loader!../../../../../../examples/groq.ts\";\n\n# Groq\n\n## Usage\n\nFirst, create an API key at the Groq Console. Then save it in your environment:\n\n```bash\nexport GROQ_API_KEY=<your-api-key>\n```\n\nThe initialize the Groq module.\n\n```ts\nimport { Groq, serviceContextFromDefaults } from \"llamaindex\";\n\nconst groq = new Groq({\n  // If you do not wish to set your API key in the environment, you may\n  // configure your API key when you initialize the Groq class.\n  // apiKey: \"<your-api-key>\",\n});\n\nconst serviceContext = serviceContextFromDefaults({ llm: groq });\n```\n\n## Load and index documents\n\nFor this example, we will use a single document. In a real-world scenario, you would have multiple documents to index.\n\n```ts\nconst document = new Document({ text: essay, id_: \"essay\" });\n\nconst index = await VectorStoreIndex.fromDocuments([document], {\n  serviceContext,\n});\n```\n\n## Query\n\n```ts\nconst queryEngine = index.asQueryEngine();\n\nconst query = \"What is the meaning of life?\";\n\nconst results = await queryEngine.query({\n  query,\n});\n```\n\n## Full Example\n\n<CodeBlock language=\"ts\" showLineNumbers>\n  {CodeSource}\n</CodeBlock>\n", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "Document"}, "__type__": "4"}, "4f525a47-cf11-408c-b008-d2f5c9bf5b18": {"__data__": {"id_": "4f525a47-cf11-408c-b008-d2f5c9bf5b18", "embedding": null, "metadata": {"filename": "llama2.md", "extension": ".md", "file_path": "modules/llms/available_llms/llama2", "file_name": "llama2.md", "file_type": "text/markdown", "file_size": 1992, "creation_date": "2024-03-08", "last_modified_date": "2024-03-02", "summary": "The documentation page provides guidance on using LlamaIndex for document indexing and querying. It covers creating a LlamaDeuce instance, loading and indexing documents, setting up a query engine, and executing queries. The examples demonstrate how to utilize LlamaIndex functionalities effectively for information retrieval tasks."}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "# LLama2\n\n## Usage\n\n```ts\nimport { Ollama, serviceContextFromDefaults } from \"llamaindex\";\n\nconst llama2LLM = new LlamaDeuce({ chatStrategy: DeuceChatStrategy.META });\n\nconst serviceContext = serviceContextFromDefaults({ llm: llama2LLM });\n```\n\n## Usage with Replication\n\n```ts\nimport {\n  Ollama,\n  ReplicateSession,\n  serviceContextFromDefaults,\n} from \"llamaindex\";\n\nconst replicateSession = new ReplicateSession({\n  replicateKey,\n});\n\nconst llama2LLM = new LlamaDeuce({\n  chatStrategy: DeuceChatStrategy.META,\n  replicateSession,\n});\n\nconst serviceContext = serviceContextFromDefaults({ llm: llama2LLM });\n```\n\n## Load and index documents\n\nFor this example, we will use a single document. In a real-world scenario, you would have multiple documents to index.\n\n```ts\nconst document = new Document({ text: essay, id_: \"essay\" });\n\nconst index = await VectorStoreIndex.fromDocuments([document], {\n  serviceContext,\n});\n```\n\n## Query\n\n```ts\nconst queryEngine = index.asQueryEngine();\n\nconst query = \"What is the meaning of life?\";\n\nconst results = await queryEngine.query({\n  query,\n});\n```\n\n## Full Example\n\n```ts\nimport {\n  LlamaDeuce,\n  Document,\n  VectorStoreIndex,\n  serviceContextFromDefaults,\n} from \"llamaindex\";\n\nasync function main() {\n  // Create an instance of the LLM\n  const llama2LLM = new LlamaDeuce({ chatStrategy: DeuceChatStrategy.META });\n\n  // Create a service context\n  const serviceContext = serviceContextFromDefaults({ llm: mistralLLM });\n\n  const document = new Document({ text: essay, id_: \"essay\" });\n\n  // Load and index documents\n  const index = await VectorStoreIndex.fromDocuments([document], {\n    serviceContext,\n  });\n\n  // get retriever\n  const retriever = index.asRetriever();\n\n  // Create a query engine\n  const queryEngine = index.asQueryEngine({\n    retriever,\n  });\n\n  const query = \"What is the meaning of life?\";\n\n  // Query\n  const response = await queryEngine.query({\n    query,\n  });\n\n  // Log the response\n  console.log(response.response);\n}\n```\n", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "Document"}, "__type__": "4"}, "f3a8e7c4-b7a3-4535-9d42-52a01e757453": {"__data__": {"id_": "f3a8e7c4-b7a3-4535-9d42-52a01e757453", "embedding": null, "metadata": {"filename": "mistral.md", "extension": ".md", "file_path": "modules/llms/available_llms/mistral", "file_name": "mistral.md", "file_type": "text/markdown", "file_size": 1625, "creation_date": "2024-03-08", "last_modified_date": "2024-03-02", "summary": "The documentation page provides guidance on using MistralAI from LlamaIndex. It covers setting up MistralAI, loading and indexing documents, querying for information, and includes a full example. Users can learn how to integrate MistralAI, index documents, create query engines, and execute queries to retrieve relevant information efficiently."}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "# Mistral\n\n## Usage\n\n```ts\nimport { Ollama, serviceContextFromDefaults } from \"llamaindex\";\n\nconst mistralLLM = new MistralAI({\n  model: \"mistral-tiny\",\n  apiKey: \"<YOUR_API_KEY>\",\n});\n\nconst serviceContext = serviceContextFromDefaults({ llm: mistralLLM });\n```\n\n## Load and index documents\n\nFor this example, we will use a single document. In a real-world scenario, you would have multiple documents to index.\n\n```ts\nconst document = new Document({ text: essay, id_: \"essay\" });\n\nconst index = await VectorStoreIndex.fromDocuments([document], {\n  serviceContext,\n});\n```\n\n## Query\n\n```ts\nconst queryEngine = index.asQueryEngine();\n\nconst query = \"What is the meaning of life?\";\n\nconst results = await queryEngine.query({\n  query,\n});\n```\n\n## Full Example\n\n```ts\nimport {\n  MistralAI,\n  Document,\n  VectorStoreIndex,\n  serviceContextFromDefaults,\n} from \"llamaindex\";\n\nasync function main() {\n  // Create an instance of the LLM\n  const mistralLLM = new MistralAI({ model: \"mistral-tiny\" });\n\n  // Create a service context\n  const serviceContext = serviceContextFromDefaults({ llm: mistralLLM });\n\n  const document = new Document({ text: essay, id_: \"essay\" });\n\n  // Load and index documents\n  const index = await VectorStoreIndex.fromDocuments([document], {\n    serviceContext,\n  });\n\n  // get retriever\n  const retriever = index.asRetriever();\n\n  // Create a query engine\n  const queryEngine = index.asQueryEngine({\n    retriever,\n  });\n\n  const query = \"What is the meaning of life?\";\n\n  // Query\n  const response = await queryEngine.query({\n    query,\n  });\n\n  // Log the response\n  console.log(response.response);\n}\n```\n", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "Document"}, "__type__": "4"}, "8c8c431d-e586-48ca-b52f-5b11f1cb2c59": {"__data__": {"id_": "8c8c431d-e586-48ca-b52f-5b11f1cb2c59", "embedding": null, "metadata": {"filename": "ollama.md", "extension": ".md", "file_path": "modules/llms/available_llms/ollama", "file_name": "ollama.md", "file_type": "text/markdown", "file_size": 1836, "creation_date": "2024-03-08", "last_modified_date": "2024-03-02", "summary": "The documentation covers using Ollama for document indexing and querying. It demonstrates creating an Ollama instance, loading a document, indexing it, and querying with a specific question. The process involves setting up a service context, utilizing VectorStoreIndex, and querying for relevant information using the LlamaIndex package."}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "# Ollama\n\n## Usage\n\n```ts\nimport { Ollama, serviceContextFromDefaults } from \"llamaindex\";\n\nconst ollamaLLM = new Ollama({ model: \"llama2\", temperature: 0.75 });\n\nconst serviceContext = serviceContextFromDefaults({\n  llm: ollamaLLM,\n  embedModel: ollamaLLM,\n});\n```\n\n## Load and index documents\n\nFor this example, we will use a single document. In a real-world scenario, you would have multiple documents to index.\n\n```ts\nconst document = new Document({ text: essay, id_: \"essay\" });\n\nconst index = await VectorStoreIndex.fromDocuments([document], {\n  serviceContext,\n});\n```\n\n## Query\n\n```ts\nconst queryEngine = index.asQueryEngine();\n\nconst query = \"What is the meaning of life?\";\n\nconst results = await queryEngine.query({\n  query,\n});\n```\n\n## Full Example\n\n```ts\nimport {\n  Ollama,\n  Document,\n  VectorStoreIndex,\n  serviceContextFromDefaults,\n} from \"llamaindex\";\n\nimport fs from \"fs/promises\";\n\nasync function main() {\n  // Create an instance of the LLM\n  const ollamaLLM = new Ollama({ model: \"llama2\", temperature: 0.75 });\n\n  const essay = await fs.readFile(\"./paul_graham_essay.txt\", \"utf-8\");\n\n  // Create a service context\n  const serviceContext = serviceContextFromDefaults({\n    embedModel: ollamaLLM, // prevent 'Set OpenAI Key in OPENAI_API_KEY env variable' error\n    llm: ollamaLLM,\n  });\n\n  const document = new Document({ text: essay, id_: \"essay\" });\n\n  // Load and index documents\n  const index = await VectorStoreIndex.fromDocuments([document], {\n    serviceContext,\n  });\n\n  // get retriever\n  const retriever = index.asRetriever();\n\n  // Create a query engine\n  const queryEngine = index.asQueryEngine({\n    retriever,\n  });\n\n  const query = \"What is the meaning of life?\";\n\n  // Query\n  const response = await queryEngine.query({\n    query,\n  });\n\n  // Log the response\n  console.log(response.response);\n}\n```\n", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "Document"}, "__type__": "4"}, "90ef0338-485f-4924-a410-c883a34207e8": {"__data__": {"id_": "90ef0338-485f-4924-a410-c883a34207e8", "embedding": null, "metadata": {"filename": "openai.md", "extension": ".md", "file_path": "modules/llms/available_llms/openai", "file_name": "openai.md", "file_type": "text/markdown", "file_size": 1742, "creation_date": "2024-03-08", "last_modified_date": "2024-03-02", "summary": "The documentation covers setting up an OpenAI model, indexing a document, creating a query engine, and querying for information using LlamaIndex. It demonstrates how to use OpenAI, index documents, and retrieve information based on a query, providing a comprehensive overview of the process in a concise manner."}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "# OpenAI\n\n```ts\nimport { OpenAI, serviceContextFromDefaults } from \"llamaindex\";\n\nconst openaiLLM = new OpenAI({ model: \"gpt-3.5-turbo\", temperature: 0, apiKey: <YOUR_API_KEY> });\n\nconst serviceContext = serviceContextFromDefaults({ llm: openaiLLM });\n```\n\nYou can setup the apiKey on the environment variables, like:\n\n```bash\nexport OPENAI_API_KEY=\"<YOUR_API_KEY>\"\n```\n\n## Load and index documents\n\nFor this example, we will use a single document. In a real-world scenario, you would have multiple documents to index.\n\n```ts\nconst document = new Document({ text: essay, id_: \"essay\" });\n\nconst index = await VectorStoreIndex.fromDocuments([document], {\n  serviceContext,\n});\n```\n\n## Query\n\n```ts\nconst queryEngine = index.asQueryEngine();\n\nconst query = \"What is the meaning of life?\";\n\nconst results = await queryEngine.query({\n  query,\n});\n```\n\n## Full Example\n\n```ts\nimport {\n  OpenAI,\n  Document,\n  VectorStoreIndex,\n  serviceContextFromDefaults,\n} from \"llamaindex\";\n\nasync function main() {\n  // Create an instance of the LLM\n  const openaiLLM = new OpenAI({ model: \"gpt-3.5-turbo\", temperature: 0 });\n\n  // Create a service context\n  const serviceContext = serviceContextFromDefaults({ llm: openaiLLM });\n\n  const document = new Document({ text: essay, id_: \"essay\" });\n\n  // Load and index documents\n  const index = await VectorStoreIndex.fromDocuments([document], {\n    serviceContext,\n  });\n\n  // get retriever\n  const retriever = index.asRetriever();\n\n  // Create a query engine\n  const queryEngine = index.asQueryEngine({\n    retriever,\n  });\n\n  const query = \"What is the meaning of life?\";\n\n  // Query\n  const response = await queryEngine.query({\n    query,\n  });\n\n  // Log the response\n  console.log(response.response);\n}\n```\n", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "Document"}, "__type__": "4"}, "46f8ad9f-4f87-4dac-b700-ed4ce553c6e7": {"__data__": {"id_": "46f8ad9f-4f87-4dac-b700-ed4ce553c6e7", "embedding": null, "metadata": {"filename": "portkey.md", "extension": ".md", "file_path": "modules/llms/available_llms/portkey", "file_name": "portkey.md", "file_type": "text/markdown", "file_size": 1609, "creation_date": "2024-03-08", "last_modified_date": "2024-03-02", "summary": "The documentation provides a guide on using Portkey LLM for document indexing and querying. It demonstrates setting up the LLM instance, creating a service context, indexing a document, querying for information, and logging the response. The example showcases how to utilize LlamaIndex functionalities efficiently in a real-world scenario."}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "# Portkey LLM\n\n## Usage\n\n```ts\nimport { Portkey, serviceContextFromDefaults } from \"llamaindex\";\n\nconst portkeyLLM = new Portkey({\n  apiKey: \"<YOUR_API_KEY>\",\n});\n\nconst serviceContext = serviceContextFromDefaults({ llm: portkeyLLM });\n```\n\n## Load and index documents\n\nFor this example, we will use a single document. In a real-world scenario, you would have multiple documents to index.\n\n```ts\nconst document = new Document({ text: essay, id_: \"essay\" });\n\nconst index = await VectorStoreIndex.fromDocuments([document], {\n  serviceContext,\n});\n```\n\n## Query\n\n```ts\nconst queryEngine = index.asQueryEngine();\n\nconst query = \"What is the meaning of life?\";\n\nconst results = await queryEngine.query({\n  query,\n});\n```\n\n## Full Example\n\n```ts\nimport {\n  Portkey,\n  Document,\n  VectorStoreIndex,\n  serviceContextFromDefaults,\n} from \"llamaindex\";\n\nasync function main() {\n  // Create an instance of the LLM\n  const portkeyLLM = new Portkey({\n    apiKey: \"<YOUR_API_KEY>\",\n  });\n\n  // Create a service context\n  const serviceContext = serviceContextFromDefaults({ llm: portkeyLLM });\n\n  const document = new Document({ text: essay, id_: \"essay\" });\n\n  // Load and index documents\n  const index = await VectorStoreIndex.fromDocuments([document], {\n    serviceContext,\n  });\n\n  // get retriever\n  const retriever = index.asRetriever();\n\n  // Create a query engine\n  const queryEngine = index.asQueryEngine({\n    retriever,\n  });\n\n  const query = \"What is the meaning of life?\";\n\n  // Query\n  const response = await queryEngine.query({\n    query,\n  });\n\n  // Log the response\n  console.log(response.response);\n}\n```\n", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "Document"}, "__type__": "4"}, "2f93ecdd-2c7a-4612-905b-7bbd784a93ee": {"__data__": {"id_": "2f93ecdd-2c7a-4612-905b-7bbd784a93ee", "embedding": null, "metadata": {"filename": "together.md", "extension": ".md", "file_path": "modules/llms/available_llms/together", "file_name": "together.md", "file_type": "text/markdown", "file_size": 1630, "creation_date": "2024-03-08", "last_modified_date": "2024-03-02", "summary": "The documentation provides a guide on using Together LLM for document indexing and querying. It covers setting up the LLM instance, creating a service context, loading and indexing documents, querying for information, and includes a full example demonstrating the process from start to finish."}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "# Together LLM\n\n## Usage\n\n```ts\nimport { TogetherLLM, serviceContextFromDefaults } from \"llamaindex\";\n\nconst togetherLLM = new TogetherLLM({\n  apiKey: \"<YOUR_API_KEY>\",\n});\n\nconst serviceContext = serviceContextFromDefaults({ llm: togetherLLM });\n```\n\n## Load and index documents\n\nFor this example, we will use a single document. In a real-world scenario, you would have multiple documents to index.\n\n```ts\nconst document = new Document({ text: essay, id_: \"essay\" });\n\nconst index = await VectorStoreIndex.fromDocuments([document], {\n  serviceContext,\n});\n```\n\n## Query\n\n```ts\nconst queryEngine = index.asQueryEngine();\n\nconst query = \"What is the meaning of life?\";\n\nconst results = await queryEngine.query({\n  query,\n});\n```\n\n## Full Example\n\n```ts\nimport {\n  TogetherLLM,\n  Document,\n  VectorStoreIndex,\n  serviceContextFromDefaults,\n} from \"llamaindex\";\n\nasync function main() {\n  // Create an instance of the LLM\n  const togetherLLM = new TogetherLLM({\n    apiKey: \"<YOUR_API_KEY>\",\n  });\n\n  // Create a service context\n  const serviceContext = serviceContextFromDefaults({ llm: togetherLLM });\n\n  const document = new Document({ text: essay, id_: \"essay\" });\n\n  // Load and index documents\n  const index = await VectorStoreIndex.fromDocuments([document], {\n    serviceContext,\n  });\n\n  // get retriever\n  const retriever = index.asRetriever();\n\n  // Create a query engine\n  const queryEngine = index.asQueryEngine({\n    retriever,\n  });\n\n  const query = \"What is the meaning of life?\";\n\n  // Query\n  const response = await queryEngine.query({\n    query,\n  });\n\n  // Log the response\n  console.log(response.response);\n}\n```\n", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "Document"}, "__type__": "4"}, "c0934c99-c258-4db8-93bf-21cae9061ec9": {"__data__": {"id_": "c0934c99-c258-4db8-93bf-21cae9061ec9", "embedding": null, "metadata": {"filename": "index.md", "extension": ".md", "file_path": "modules/llms/index", "file_name": "index.md", "file_type": "text/markdown", "file_size": 1107, "creation_date": "2024-03-08", "last_modified_date": "2024-03-02", "summary": "The LlamaIndex documentation page covers Large Language Models (LLMs) like `gpt-3.5-turbo` for text processing. It explains setting LLMs in `ServiceContext`, mentions Azure OpenAI setup, recommends Ollama LLM for local use, and lists API references for OpenAI and ServiceContext."}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "---\nsidebar_position: 3\n---\n\n# Large Language Models (LLMs)\n\nThe LLM is responsible for reading text and generating natural language responses to queries. By default, LlamaIndex.TS uses `gpt-3.5-turbo`.\n\nThe LLM can be explicitly set in the `ServiceContext` object.\n\n```typescript\nimport { OpenAI, serviceContextFromDefaults } from \"llamaindex\";\n\nconst openaiLLM = new OpenAI({ model: \"gpt-3.5-turbo\", temperature: 0 });\n\nconst serviceContext = serviceContextFromDefaults({ llm: openaiLLM });\n```\n\n## Azure OpenAI\n\nTo use Azure OpenAI, you only need to set a few environment variables.\n\nFor example:\n\n```\nexport AZURE_OPENAI_KEY=\"<YOUR KEY HERE>\"\nexport AZURE_OPENAI_ENDPOINT=\"<YOUR ENDPOINT, see https://learn.microsoft.com/en-us/azure/ai-services/openai/quickstart?tabs=command-line%2Cpython&pivots=rest-api>\"\nexport AZURE_OPENAI_DEPLOYMENT=\"gpt-4\" # or some other deployment name\n```\n\n## Local LLM\n\nFor local LLMs, currently we recommend the use of Ollama LLM.\n\n## API Reference\n\n- OpenAI\n- ServiceContext\n", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "Document"}, "__type__": "4"}, "5ef7d2dd-642c-4542-8b36-2632ad62b649": {"__data__": {"id_": "5ef7d2dd-642c-4542-8b36-2632ad62b649", "embedding": null, "metadata": {"filename": "node_parser.md", "extension": ".md", "file_path": "modules/node_parser", "file_name": "node_parser.md", "file_type": "text/markdown", "file_size": 2733, "creation_date": "2024-03-08", "last_modified_date": "2024-03-02", "summary": "The LlamaIndex documentation page covers the functionality of NodeParser for splitting documents into nodes, including SimpleNodeParser and MarkdownNodeParser. It also introduces TextSplitter for sentence splitting. The provided code snippets demonstrate how to use these modules to parse and split text effectively for document processing."}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "---\nsidebar_position: 4\n---\n\n# NodeParser\n\nThe `NodeParser` in LlamaIndex is responsible for splitting `Document` objects into more manageable `Node` objects. When you call `.fromDocuments()`, the `NodeParser` from the `ServiceContext` is used to do this automatically for you. Alternatively, you can use it to split documents ahead of time.\n\n```typescript\nimport { Document, SimpleNodeParser } from \"llamaindex\";\n\nconst nodeParser = new SimpleNodeParser();\nconst nodes = nodeParser.getNodesFromDocuments([\n  new Document({ text: \"I am 10 years old. John is 20 years old.\" }),\n]);\n```\n\n## TextSplitter\n\nThe underlying text splitter will split text by sentences. It can also be used as a standalone module for splitting raw text.\n\n```typescript\nimport { SentenceSplitter } from \"llamaindex\";\n\nconst splitter = new SentenceSplitter({ chunkSize: 1 });\n\nconst textSplits = splitter.splitText(\"Hello World\");\n```\n\n## MarkdownNodeParser\n\nThe `MarkdownNodeParser` is a more advanced `NodeParser` that can handle markdown documents. It will split the markdown into nodes and then parse the nodes into a `Document` object.\n\n```typescript\nimport { MarkdownNodeParser } from \"llamaindex\";\n\nconst nodeParser = new MarkdownNodeParser();\n\nconst nodes = nodeParser.getNodesFromDocuments([\n  new Document({\n    text: `# Main Header\nMain content\n\n# Header 2\nHeader 2 content\n\n## Sub-header\nSub-header content\n\n  `,\n  }),\n]);\n```\n\nThe output metadata will be something like:\n\n```bash\n[\n  TextNode {\n    id_: '008e41a8-b097-487c-bee8-bd88b9455844',\n    metadata: { 'Header 1': 'Main Header' },\n    excludedEmbedMetadataKeys: [],\n    excludedLlmMetadataKeys: [],\n    relationships: { PARENT: [Array] },\n    hash: 'KJ5e/um/RkHaNR6bonj9ormtZY7I8i4XBPVYHXv1A5M=',\n    text: 'Main Header\\nMain content',\n    textTemplate: '',\n    metadataSeparator: '\\n'\n  },\n  TextNode {\n    id_: '0f5679b3-ba63-4aff-aedc-830c4208d0b5',\n    metadata: { 'Header 1': 'Header 2' },\n    excludedEmbedMetadataKeys: [],\n    excludedLlmMetadataKeys: [],\n    relationships: { PARENT: [Array] },\n    hash: 'IP/g/dIld3DcbK+uHzDpyeZ9IdOXY4brxhOIe7wc488=',\n    text: 'Header 2\\nHeader 2 content',\n    textTemplate: '',\n    metadataSeparator: '\\n'\n  },\n  TextNode {\n    id_: 'e81e9bd0-121c-4ead-8ca7-1639d65fdf90',\n    metadata: { 'Header 1': 'Header 2', 'Header 2': 'Sub-header' },\n    excludedEmbedMetadataKeys: [],\n    excludedLlmMetadataKeys: [],\n    relationships: { PARENT: [Array] },\n    hash: 'B3kYNnxaYi9ghtAgwza0ZEVKF4MozobkNUlcekDL7JQ=',\n    text: 'Sub-header\\nSub-header content',\n    textTemplate: '',\n    metadataSeparator: '\\n'\n  }\n]\n```\n\n## API Reference\n\n- SimpleNodeParser\n- SentenceSplitter\n", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "Document"}, "__type__": "4"}, "b9897658-0aa1-42b0-85b2-2b5c268a46d9": {"__data__": {"id_": "b9897658-0aa1-42b0-85b2-2b5c268a46d9", "embedding": null, "metadata": {"filename": "cohere_reranker.md", "extension": ".md", "file_path": "modules/node_postprocessors/cohere_reranker", "file_name": "cohere_reranker.md", "file_type": "text/markdown", "file_size": 1876, "creation_date": "2024-03-08", "last_modified_date": "2024-03-02", "summary": "The documentation introduces the Cohere Reranker, a tool that enhances search results using the Cohere API. It guides users through setup, document indexing, and result retrieval customization. By combining the CohereRerank class with an API key, users can improve search relevance and retrieve multiple relevant documents efficiently."}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "# Cohere Reranker\n\nThe Cohere Reranker is a postprocessor that uses the Cohere API to rerank the results of a search query.\n\n## Setup\n\nFirstly, you will need to install the `llamaindex` package.\n\n```bash\npnpm install llamaindex\n```\n\nNow, you will need to sign up for an API key at Cohere. Once you have your API key you can import the necessary modules and create a new instance of the `CohereRerank` class.\n\n```ts\nimport {\n  CohereRerank,\n  Document,\n  OpenAI,\n  VectorStoreIndex,\n  serviceContextFromDefaults,\n} from \"llamaindex\";\n```\n\n## Load and index documents\n\nFor this example, we will use a single document. In a real-world scenario, you would have multiple documents to index.\n\n```ts\nconst document = new Document({ text: essay, id_: \"essay\" });\n\nconst serviceContext = serviceContextFromDefaults({\n  llm: new OpenAI({ model: \"gpt-3.5-turbo\", temperature: 0.1 }),\n});\n\nconst index = await VectorStoreIndex.fromDocuments([document], {\n  serviceContext,\n});\n```\n\n## Increase similarity topK to retrieve more results\n\nThe default value for `similarityTopK` is 2. This means that only the most similar document will be returned. To retrieve more results, you can increase the value of `similarityTopK`.\n\n```ts\nconst retriever = index.asRetriever();\nretriever.similarityTopK = 5;\n```\n\n## Create a new instance of the CohereRerank class\n\nThen you can create a new instance of the `CohereRerank` class and pass in your API key and the number of results you want to return.\n\n```ts\nconst nodePostprocessor = new CohereRerank({\n  apiKey: \"<COHERE_API_KEY>\",\n  topN: 4,\n});\n```\n\n## Create a query engine with the retriever and node postprocessor\n\n```ts\nconst queryEngine = index.asQueryEngine({\n  retriever,\n  nodePostprocessors: [nodePostprocessor],\n});\n\n// log the response\nconst response = await queryEngine.query(\"Where did the author grown up?\");\n```\n", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "Document"}, "__type__": "4"}, "407d15ae-3626-4ad1-86c8-8a317ed7c239": {"__data__": {"id_": "407d15ae-3626-4ad1-86c8-8a317ed7c239", "embedding": null, "metadata": {"filename": "index.md", "extension": ".md", "file_path": "modules/node_postprocessors/index", "file_name": "index.md", "file_type": "text/markdown", "file_size": 2888, "creation_date": "2024-03-08", "last_modified_date": "2024-03-02", "summary": "Node postprocessors in LlamaIndex are modules that transform or filter nodes after retrieval but before response synthesis. Users can apply built-in or custom postprocessors. Examples include filtering nodes based on similarity scores and reranking nodes using a trained model. These postprocessors are commonly used in query engines for enhanced search functionality."}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "# Node Postprocessors\n\n## Concept\n\nNode postprocessors are a set of modules that take a set of nodes, and apply some kind of transformation or filtering before returning them.\n\nIn LlamaIndex, node postprocessors are most commonly applied within a query engine, after the node retrieval step and before the response synthesis step.\n\nLlamaIndex offers several node postprocessors for immediate use, while also providing a simple API for adding your own custom postprocessors.\n\n## Usage Pattern\n\nAn example of using a node postprocessors is below:\n\n```ts\nimport {\n  Node,\n  NodeWithScore,\n  SimilarityPostprocessor,\n  CohereRerank,\n} from \"llamaindex\";\n\nconst nodes: NodeWithScore[] = [\n  {\n    node: new TextNode({ text: \"hello world\" }),\n    score: 0.8,\n  },\n  {\n    node: new TextNode({ text: \"LlamaIndex is the best\" }),\n    score: 0.6,\n  },\n];\n\n// similarity postprocessor: filter nodes below 0.75 similarity score\nconst processor = new SimilarityPostprocessor({\n  similarityCutoff: 0.7,\n});\n\nconst filteredNodes = processor.postprocessNodes(nodes);\n\n// cohere rerank: rerank nodes given query using trained model\nconst reranker = new CohereRerank({\n  apiKey: \"<COHERE_API_KEY>\",\n  topN: 2,\n});\n\nconst rerankedNodes = await reranker.postprocessNodes(nodes, \"<user_query>\");\n\nconsole.log(filteredNodes, rerankedNodes);\n```\n\nNow you can use the `filteredNodes` and `rerankedNodes` in your application.\n\n## Using Node Postprocessors in LlamaIndex\n\nMost commonly, node-postprocessors will be used in a query engine, where they are applied to the nodes returned from a retriever, and before the response synthesis step.\n\n### Using Node Postprocessors in a Query Engine\n\n```ts\nimport { Node, NodeWithScore, SimilarityPostprocessor, CohereRerank } from \"llamaindex\";\n\nconst nodes: NodeWithScore[] = [\n  {\n    node: new TextNode({ text: \"hello world\" }),\n    score: 0.8,\n  },\n  {\n    node: new TextNode({ text: \"LlamaIndex is the best\" }),\n    score: 0.6,\n  }\n];\n\n// cohere rerank: rerank nodes given query using trained model\nconst reranker = new CohereRerank({\n  apiKey: \"<COHERE_API_KEY>,\n  topN: 2,\n})\n\nconst document = new Document({ text: \"essay\", id_: \"essay\" });\n\nconst serviceContext = serviceContextFromDefaults({\n  llm: new OpenAI({ model: \"gpt-3.5-turbo\", temperature: 0.1 }),\n});\n\nconst index = await VectorStoreIndex.fromDocuments([document], {\n  serviceContext,\n});\n\nconst queryEngine = index.asQueryEngine({\n  nodePostprocessors: [processor, reranker],\n});\n\n// all node post-processors will be applied during each query\nconst response = await queryEngine.query(\"<user_query>\");\n```\n\n### Using with retrieved nodes\n\n```ts\nimport { SimilarityPostprocessor } from \"llamaindex\";\n\nnodes = await index.asRetriever().retrieve(\"test query str\");\n\nconst processor = new SimilarityPostprocessor({\n  similarityCutoff: 0.7,\n});\n\nconst filteredNodes = processor.postprocessNodes(nodes);\n```\n", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "Document"}, "__type__": "4"}, "993a248f-88b6-4a11-b667-e06da5b544c7": {"__data__": {"id_": "993a248f-88b6-4a11-b667-e06da5b544c7", "embedding": null, "metadata": {"filename": "index.md", "extension": ".md", "file_path": "modules/prompt/index", "file_name": "index.md", "file_type": "text/markdown", "file_size": 2717, "creation_date": "2024-03-08", "last_modified_date": "2024-03-02", "summary": "The LlamaIndex documentation page explains the significance of prompts in LLMs, detailing their role in indexing, insertion, traversal, and answer synthesis. It outlines two methods for customizing prompts: customizing the default prompt on initialization and customizing submodules prompts. Users can enhance behavior by creating custom prompt templates and overriding default prompts at different levels for tailored interactions."}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "# Prompts\n\nPrompting is the fundamental input that gives LLMs their expressive power. LlamaIndex uses prompts to build the index, do insertion, perform traversal during querying, and to synthesize the final answer.\n\nUsers may also provide their own prompt templates to further customize the behavior of the framework. The best method for customizing is copying the default prompt from the link above, and using that as the base for any modifications.\n\n## Usage Pattern\n\nCurrently, there are two ways to customize prompts in LlamaIndex:\n\nFor both methods, you will need to create an function that overrides the default prompt.\n\n```ts\n// Define a custom prompt\nconst newTextQaPrompt: TextQaPrompt = ({ context, query }) => {\n  return `Context information is below.\n---------------------\n${context}\n---------------------\nGiven the context information and not prior knowledge, answer the query.\nAnswer the query in the style of a Sherlock Holmes detective novel.\nQuery: ${query}\nAnswer:`;\n};\n```\n\n### 1. Customizing the default prompt on initialization\n\nThe first method is to create a new instance of `ResponseSynthesizer` (or the module you would like to update the prompt) and pass the custom prompt to the `responseBuilder` parameter. Then, pass the instance to the `asQueryEngine` method of the index.\n\n```ts\n// Create an instance of response synthesizer\nconst responseSynthesizer = new ResponseSynthesizer({\n  responseBuilder: new CompactAndRefine(serviceContext, newTextQaPrompt),\n});\n\n// Create index\nconst index = await VectorStoreIndex.fromDocuments([document], {\n  serviceContext,\n});\n\n// Query the index\nconst queryEngine = index.asQueryEngine({ responseSynthesizer });\n\nconst response = await queryEngine.query({\n  query: \"What did the author do in college?\",\n});\n```\n\n### 2. Customizing submodules prompt\n\nThe second method is that most of the modules in LlamaIndex have a `getPrompts` and a `updatePrompt` method that allows you to override the default prompt. This method is useful when you want to change the prompt on the fly or in submodules on a more granular level.\n\n```ts\n// Create index\nconst index = await VectorStoreIndex.fromDocuments([document], {\n  serviceContext,\n});\n\n// Query the index\nconst queryEngine = index.asQueryEngine();\n\n// Get a list of prompts for the query engine\nconst prompts = queryEngine.getPrompts();\n\n// output: { \"responseSynthesizer:textQATemplate\": defaultTextQaPrompt, \"responseSynthesizer:refineTemplate\": defaultRefineTemplatePrompt }\n\n// Now, we can override the default prompt\nqueryEngine.updatePrompt({\n  \"responseSynthesizer:textQATemplate\": newTextQaPrompt,\n});\n\nconst response = await queryEngine.query({\n  query: \"What did the author do in college?\",\n});\n```\n", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "Document"}, "__type__": "4"}, "c1ab1442-911c-4801-ae63-25a9f1d9d4b5": {"__data__": {"id_": "c1ab1442-911c-4801-ae63-25a9f1d9d4b5", "embedding": null, "metadata": {"filename": "index.md", "extension": ".md", "file_path": "modules/query_engines/index", "file_name": "index.md", "file_type": "text/markdown", "file_size": 2165, "creation_date": "2024-03-08", "last_modified_date": "2024-03-02", "summary": "The LlamaIndex documentation page provides insights into the SubQuestion Query Engine, which breaks down queries into multiple parts, retrieves answers for each, and combines them for a comprehensive response. It introduces Tools like QueryEngineTool for executing queries and mentions the option to stream responses for efficient processing."}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "# QueryEngine\n\nA query engine wraps a `Retriever` and a `ResponseSynthesizer` into a pipeline, that will use the query string to fetech nodes and then send them to the LLM to generate a response.\n\n```typescript\nconst queryEngine = index.asQueryEngine();\nconst response = await queryEngine.query({ query: \"query string\" });\n```\n\nThe `query` function also supports streaming, just add `stream: true` as an option:\n\n```typescript\nconst stream = await queryEngine.query({ query: \"query string\", stream: true });\nfor await (const chunk of stream) {\n  process.stdout.write(chunk.response);\n}\n```\n\n## Sub Question Query Engine\n\nThe basic concept of the Sub Question Query Engine is that it splits a single query into multiple queries, gets an answer for each of those queries, and then combines those different answers into a single coherent response for the user. You can think of it as the \"think this through step by step\" prompt technique but iterating over your data sources!\n\n### Getting Started\n\nThe easiest way to start trying the Sub Question Query Engine is running the subquestion.ts file in examples.\n\n```bash\nnpx ts-node subquestion.ts\n```\n\n### Tools\n\nSubQuestionQueryEngine is implemented with Tools. The basic idea of Tools is that they are executable options for the large language model. In this case, our SubQuestionQueryEngine relies on QueryEngineTool, which as you guessed it is a tool to run queries on a QueryEngine. This allows us to give the model an option to query different documents for different questions for example. You could also imagine that the SubQuestionQueryEngine could use a Tool that searches for something on the web or gets an answer using Wolfram Alpha.\n\nYou can learn more about Tools by taking a look at the LlamaIndex Python documentation https://gpt-index.readthedocs.io/en/latest/core_modules/agent_modules/tools/root.html\n\n## API Reference\n\n- RetrieverQueryEngine\n- SubQuestionQueryEngine\n- QueryEngineTool\n", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "Document"}, "__type__": "4"}, "0d7166cf-b1cb-4653-a649-45cb053056f5": {"__data__": {"id_": "0d7166cf-b1cb-4653-a649-45cb053056f5", "embedding": null, "metadata": {"filename": "metadata_filtering.md", "extension": ".md", "file_path": "modules/query_engines/metadata_filtering", "file_name": "metadata_filtering.md", "file_type": "text/markdown", "file_size": 3403, "creation_date": "2024-03-08", "last_modified_date": "2024-03-02", "summary": "The LlamaIndex documentation page explains metadata filtering for document retrieval. It covers setting up the ChromaDB vector store, creating documents with metadata, and querying the index with metadata filters. The example demonstrates filtering documents based on metadata like dog color and ID for accurate search results."}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "# Metadata Filtering\n\nMetadata filtering is a way to filter the documents that are returned by a query based on the metadata associated with the documents. This is useful when you want to filter the documents based on some metadata that is not part of the document text.\n\nYou can also check our multi-tenancy blog post to see how metadata filtering can be used in a multi-tenant environment. [https://blog.llamaindex.ai/building-multi-tenancy-rag-system-with-llamaindex-0d6ab4e0c44b] (the article uses the Python version of LlamaIndex, but the concepts are the same).\n\n## Setup\n\nFirstly if you haven't already, you need to install the `llamaindex` package:\n\n```bash\npnpm i llamaindex\n```\n\nThen you can import the necessary modules from `llamaindex`:\n\n```ts\nimport {\n  ChromaVectorStore,\n  Document,\n  VectorStoreIndex,\n  storageContextFromDefaults,\n} from \"llamaindex\";\n\nconst collectionName = \"dog_colors\";\n```\n\n## Creating documents with metadata\n\nYou can create documents with metadata using the `Document` class:\n\n```ts\nconst docs = [\n  new Document({\n    text: \"The dog is brown\",\n    metadata: {\n      color: \"brown\",\n      dogId: \"1\",\n    },\n  }),\n  new Document({\n    text: \"The dog is red\",\n    metadata: {\n      color: \"red\",\n      dogId: \"2\",\n    },\n  }),\n];\n```\n\n## Creating a ChromaDB vector store\n\nYou can create a `ChromaVectorStore` to store the documents:\n\n```ts\nconst chromaVS = new ChromaVectorStore({ collectionName });\nconst serviceContext = await storageContextFromDefaults({\n  vectorStore: chromaVS,\n});\n\nconst index = await VectorStoreIndex.fromDocuments(docs, {\n  storageContext: serviceContext,\n});\n```\n\n## Querying the index with metadata filtering\n\nNow you can query the index with metadata filtering using the `preFilters` option:\n\n```ts\nconst queryEngine = index.asQueryEngine({\n  preFilters: {\n    filters: [\n      {\n        key: \"dogId\",\n        value: \"2\",\n        filterType: \"ExactMatch\",\n      },\n    ],\n  },\n});\n\nconst response = await queryEngine.query({\n  query: \"What is the color of the dog?\",\n});\n\nconsole.log(response.toString());\n```\n\n## Full Code\n\n```ts\nimport {\n  ChromaVectorStore,\n  Document,\n  VectorStoreIndex,\n  storageContextFromDefaults,\n} from \"llamaindex\";\n\nconst collectionName = \"dog_colors\";\n\nasync function main() {\n  try {\n    const docs = [\n      new Document({\n        text: \"The dog is brown\",\n        metadata: {\n          color: \"brown\",\n          dogId: \"1\",\n        },\n      }),\n      new Document({\n        text: \"The dog is red\",\n        metadata: {\n          color: \"red\",\n          dogId: \"2\",\n        },\n      }),\n    ];\n\n    console.log(\"Creating ChromaDB vector store\");\n    const chromaVS = new ChromaVectorStore({ collectionName });\n    const ctx = await storageContextFromDefaults({ vectorStore: chromaVS });\n\n    console.log(\"Embedding documents and adding to index\");\n    const index = await VectorStoreIndex.fromDocuments(docs, {\n      storageContext: ctx,\n    });\n\n    console.log(\"Querying index\");\n    const queryEngine = index.asQueryEngine({\n      preFilters: {\n        filters: [\n          {\n            key: \"dogId\",\n            value: \"2\",\n            filterType: \"ExactMatch\",\n          },\n        ],\n      },\n    });\n    const response = await queryEngine.query({\n      query: \"What is the color of the dog?\",\n    });\n    console.log(response.toString());\n  } catch (e) {\n    console.error(e);\n  }\n}\n\nmain();\n```\n", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "Document"}, "__type__": "4"}, "8dca20f4-c071-411c-ae8f-a712714a5b97": {"__data__": {"id_": "8dca20f4-c071-411c-ae8f-a712714a5b97", "embedding": null, "metadata": {"filename": "router_query_engine.md", "extension": ".md", "file_path": "modules/query_engines/router_query_engine", "file_name": "router_query_engine.md", "file_type": "text/markdown", "file_size": 4662, "creation_date": "2024-03-08", "last_modified_date": "2024-03-02", "summary": "The tutorial introduces a custom router query engine in LlamaIndex that selects from various query engines to execute queries. It covers setting up, loading data, defining rules, creating indices, query engines, and a router query engine. The example demonstrates querying for summaries and specific context using different query engines."}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "# Router Query Engine\n\nIn this tutorial, we define a custom router query engine that selects one out of several candidate query engines to execute a query.\n\n## Setup\n\nFirst, we need to install import the necessary modules from `llamaindex`:\n\n```bash\npnpm i lamaindex\n```\n\n```ts\nimport {\n  OpenAI,\n  RouterQueryEngine,\n  SimpleDirectoryReader,\n  SimpleNodeParser,\n  SummaryIndex,\n  VectorStoreIndex,\n  serviceContextFromDefaults,\n} from \"llamaindex\";\n```\n\n## Loading Data\n\nNext, we need to load some data. We will use the `SimpleDirectoryReader` to load documents from a directory:\n\n```ts\nconst documents = await new SimpleDirectoryReader().loadData({\n  directoryPath: \"node_modules/llamaindex/examples\",\n});\n```\n\n## Service Context\n\nNext, we need to define some basic rules and parse the documents into nodes. We will use the `SimpleNodeParser` to parse the documents into nodes and `ServiceContext` to define the rules (eg. LLM API key, chunk size, etc.):\n\n```ts\nconst nodeParser = new SimpleNodeParser({\n  chunkSize: 1024,\n});\n\nconst serviceContext = serviceContextFromDefaults({\n  nodeParser,\n  llm: new OpenAI(),\n});\n```\n\n## Creating Indices\n\nNext, we need to create some indices. We will create a `VectorStoreIndex` and a `SummaryIndex`:\n\n```ts\nconst vectorIndex = await VectorStoreIndex.fromDocuments(documents, {\n  serviceContext,\n});\n\nconst summaryIndex = await SummaryIndex.fromDocuments(documents, {\n  serviceContext,\n});\n```\n\n## Creating Query Engines\n\nNext, we need to create some query engines. We will create a `VectorStoreQueryEngine` and a `SummaryQueryEngine`:\n\n```ts\nconst vectorQueryEngine = vectorIndex.asQueryEngine();\nconst summaryQueryEngine = summaryIndex.asQueryEngine();\n```\n\n## Creating a Router Query Engine\n\nNext, we need to create a router query engine. We will use the `RouterQueryEngine` to create a router query engine:\n\nWe're defining two query engines, one for summarization and one for retrieving specific context. The router query engine will select the most appropriate query engine based on the query.\n\n```ts\nconst queryEngine = RouterQueryEngine.fromDefaults({\n  queryEngineTools: [\n    {\n      queryEngine: vectorQueryEngine,\n      description: \"Useful for summarization questions related to Abramov\",\n    },\n    {\n      queryEngine: summaryQueryEngine,\n      description: \"Useful for retrieving specific context from Abramov\",\n    },\n  ],\n  serviceContext,\n});\n```\n\n## Querying the Router Query Engine\n\nFinally, we can query the router query engine:\n\n```ts\nconst summaryResponse = await queryEngine.query({\n  query: \"Give me a summary about his past experiences?\",\n});\n\nconsole.log({\n  answer: summaryResponse.response,\n  metadata: summaryResponse?.metadata?.selectorResult,\n});\n```\n\n## Full code\n\n```ts\nimport {\n  OpenAI,\n  RouterQueryEngine,\n  SimpleDirectoryReader,\n  SimpleNodeParser,\n  SummaryIndex,\n  VectorStoreIndex,\n  serviceContextFromDefaults,\n} from \"llamaindex\";\n\nasync function main() {\n  // Load documents from a directory\n  const documents = await new SimpleDirectoryReader().loadData({\n    directoryPath: \"node_modules/llamaindex/examples\",\n  });\n\n  // Parse the documents into nodes\n  const nodeParser = new SimpleNodeParser({\n    chunkSize: 1024,\n  });\n\n  // Create a service context\n  const serviceContext = serviceContextFromDefaults({\n    nodeParser,\n    llm: new OpenAI(),\n  });\n\n  // Create indices\n  const vectorIndex = await VectorStoreIndex.fromDocuments(documents, {\n    serviceContext,\n  });\n\n  const summaryIndex = await SummaryIndex.fromDocuments(documents, {\n    serviceContext,\n  });\n\n  // Create query engines\n  const vectorQueryEngine = vectorIndex.asQueryEngine();\n  const summaryQueryEngine = summaryIndex.asQueryEngine();\n\n  // Create a router query engine\n  const queryEngine = RouterQueryEngine.fromDefaults({\n    queryEngineTools: [\n      {\n        queryEngine: vectorQueryEngine,\n        description: \"Useful for summarization questions related to Abramov\",\n      },\n      {\n        queryEngine: summaryQueryEngine,\n        description: \"Useful for retrieving specific context from Abramov\",\n      },\n    ],\n    serviceContext,\n  });\n\n  // Query the router query engine\n  const summaryResponse = await queryEngine.query({\n    query: \"Give me a summary about his past experiences?\",\n  });\n\n  console.log({\n    answer: summaryResponse.response,\n    metadata: summaryResponse?.metadata?.selectorResult,\n  });\n\n  const specificResponse = await queryEngine.query({\n    query: \"Tell me about abramov first job?\",\n  });\n\n  console.log({\n    answer: specificResponse.response,\n    metadata: specificResponse.metadata.selectorResult,\n  });\n}\n\nmain().then(() => console.log(\"Done\"));\n```\n", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "Document"}, "__type__": "4"}, "677bdc8e-44ed-4fb5-a694-1fe9c14e5344": {"__data__": {"id_": "677bdc8e-44ed-4fb5-a694-1fe9c14e5344", "embedding": null, "metadata": {"filename": "response_synthesizer.md", "extension": ".md", "file_path": "modules/response_synthesizer", "file_name": "response_synthesizer.md", "file_type": "text/markdown", "file_size": 2298, "creation_date": "2024-03-08", "last_modified_date": "2024-03-02", "summary": "The ResponseSynthesizer in LlamaIndex generates responses by refining text chunks based on the query. It offers modes like Refine, CompactAndRefine, TreeSummarize, and SimpleResponseBuilder for detailed answers or summarization. The API includes functions for synthesizing responses and supports streaming. The provided TypeScript example demonstrates how to use ResponseSynthesizer effectively."}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "---\nsidebar_position: 6\n---\n\n# ResponseSynthesizer\n\nThe ResponseSynthesizer is responsible for sending the query, nodes, and prompt templates to the LLM to generate a response. There are a few key modes for generating a response:\n\n- `Refine`: \"create and refine\" an answer by sequentially going through each retrieved text chunk.\n  This makes a separate LLM call per Node. Good for more detailed answers.\n- `CompactAndRefine` (default): \"compact\" the prompt during each LLM call by stuffing as\n  many text chunks that can fit within the maximum prompt size. If there are\n  too many chunks to stuff in one prompt, \"create and refine\" an answer by going through\n  multiple compact prompts. The same as `refine`, but should result in less LLM calls.\n- `TreeSummarize`: Given a set of text chunks and the query, recursively construct a tree\n  and return the root node as the response. Good for summarization purposes.\n- `SimpleResponseBuilder`: Given a set of text chunks and the query, apply the query to each text\n  chunk while accumulating the responses into an array. Returns a concatenated string of all\n  responses. Good for when you need to run the same query separately against each text\n  chunk.\n\n```typescript\nimport { NodeWithScore, ResponseSynthesizer, TextNode } from \"llamaindex\";\n\nconst responseSynthesizer = new ResponseSynthesizer();\n\nconst nodesWithScore: NodeWithScore[] = [\n  {\n    node: new TextNode({ text: \"I am 10 years old.\" }),\n    score: 1,\n  },\n  {\n    node: new TextNode({ text: \"John is 20 years old.\" }),\n    score: 0.5,\n  },\n];\n\nconst response = await responseSynthesizer.synthesize({\n  query: \"What age am I?\",\n  nodesWithScore,\n});\nconsole.log(response.response);\n```\n\nThe `synthesize` function also supports streaming, just add `stream: true` as an option:\n\n```typescript\nconst stream = await responseSynthesizer.synthesize({\n  query: \"What age am I?\",\n  nodesWithScore,\n  stream: true,\n});\nfor await (const chunk of stream) {\n  process.stdout.write(chunk.response);\n}\n```\n\n## API Reference\n\n- ResponseSynthesizer\n- Refine\n- CompactAndRefine\n- TreeSummarize\n- SimpleResponseBuilder\n", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "Document"}, "__type__": "4"}, "557da04d-193f-4920-a464-4b57c431255a": {"__data__": {"id_": "557da04d-193f-4920-a464-4b57c431255a", "embedding": null, "metadata": {"filename": "retriever.md", "extension": ".md", "file_path": "modules/retriever", "file_name": "retriever.md", "file_type": "text/markdown", "file_size": 684, "creation_date": "2024-03-08", "last_modified_date": "2024-03-02", "summary": "The LlamaIndex documentation page explains retrievers used to fetch nodes from an index using query strings. It introduces `VectorIndexRetriever` for top-k similar nodes and `SummaryIndexRetriever` for fetching all nodes regardless of the query. The page provides code examples and references to different retriever types available in the API."}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "---\nsidebar_position: 5\n---\n\n# Retriever\n\nA retriever in LlamaIndex is what is used to fetch `Node`s from an index using a query string. Aa `VectorIndexRetriever` will fetch the top-k most similar nodes. Meanwhile, a `SummaryIndexRetriever` will fetch all nodes no matter the query.\n\n```typescript\nconst retriever = vector_index.asRetriever();\nretriever.similarityTopK = 3;\n\n// Fetch nodes!\nconst nodesWithScore = await retriever.retrieve(\"query string\");\n```\n\n## API Reference\n\n- SummaryIndexRetriever\n- SummaryIndexLLMRetriever\n- VectorIndexRetriever\n", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "Document"}, "__type__": "4"}, "9e655577-b8fb-48ff-a206-5d4567bd3147": {"__data__": {"id_": "9e655577-b8fb-48ff-a206-5d4567bd3147", "embedding": null, "metadata": {"filename": "storage.md", "extension": ".md", "file_path": "modules/storage", "file_name": "storage.md", "file_type": "text/markdown", "file_size": 695, "creation_date": "2024-03-08", "last_modified_date": "2024-03-02", "summary": "The LlamaIndex documentation page explains how to set up storage in LlamaIndex.TS using a `StorageContext` object. By configuring the `persistDir` and attaching it to an index, users can save and load data from disk. The page also mentions future integrations and provides code examples for implementation."}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "---\nsidebar_position: 7\n---\n\n# Storage\n\nStorage in LlamaIndex.TS works automatically once you've configured a `StorageContext` object. Just configure the `persistDir` and attach it to an index.\n\nRight now, only saving and loading from disk is supported, with future integrations planned!\n\n```typescript\nimport { Document, VectorStoreIndex, storageContextFromDefaults } from \"./src\";\n\nconst storageContext = await storageContextFromDefaults({\n  persistDir: \"./storage\",\n});\n\nconst document = new Document({ text: \"Test Text\" });\nconst index = await VectorStoreIndex.fromDocuments([document], {\n  storageContext,\n});\n```\n\n## API Reference\n\n- StorageContext\n", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "Document"}, "__type__": "4"}, "7ff97c66-6031-49e9-9e65-078432375089": {"__data__": {"id_": "7ff97c66-6031-49e9-9e65-078432375089", "embedding": null, "metadata": {"filename": "qdrant.md", "extension": ".md", "file_path": "modules/vector_stores/qdrant", "file_name": "qdrant.md", "file_type": "text/markdown", "file_size": 1741, "creation_date": "2024-03-08", "last_modified_date": "2024-03-02", "summary": "The documentation provides a guide on using Qdrant Vector Store with LlamaIndex. It covers setting up a Qdrant instance, importing modules, loading documents, setting up the index, querying the index, and includes a full code example. The focus is on utilizing Qdrant for efficient document indexing and querying."}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {}, "text": "# Qdrant Vector Store\n\nTo run this example, you need to have a Qdrant instance running. You can run it with Docker:\n\n```bash\ndocker pull qdrant/qdrant\ndocker run -p 6333:6333 qdrant/qdrant\n```\n\n## Importing the modules\n\n```ts\nimport fs from \"node:fs/promises\";\nimport { Document, VectorStoreIndex, QdrantVectorStore } from \"llamaindex\";\n```\n\n## Load the documents\n\n```ts\nconst path = \"node_modules/llamaindex/examples/abramov.txt\";\nconst essay = await fs.readFile(path, \"utf-8\");\n```\n\n## Setup Qdrant\n\n```ts\nconst vectorStore = new QdrantVectorStore({\n  url: \"http://localhost:6333\",\n});\n```\n\n## Setup the index\n\n```ts\nconst document = new Document({ text: essay, id_: path });\n\nconst index = await VectorStoreIndex.fromDocuments([document], {\n  vectorStore,\n});\n```\n\n## Query the index\n\n```ts\nconst queryEngine = index.asQueryEngine();\n\nconst response = await queryEngine.query({\n  query: \"What did the author do in college?\",\n});\n\n// Output response\nconsole.log(response.toString());\n```\n\n## Full code\n\n```ts\nimport fs from \"node:fs/promises\";\nimport { Document, VectorStoreIndex, QdrantVectorStore } from \"llamaindex\";\n\nasync function main() {\n  const path = \"node_modules/llamaindex/examples/abramov.txt\";\n  const essay = await fs.readFile(path, \"utf-8\");\n\n  const vectorStore = new QdrantVectorStore({\n    url: \"http://localhost:6333\",\n  });\n\n  const document = new Document({ text: essay, id_: path });\n\n  const index = await VectorStoreIndex.fromDocuments([document], {\n    vectorStore,\n  });\n\n  const queryEngine = index.asQueryEngine();\n\n  const response = await queryEngine.query({\n    query: \"What did the author do in college?\",\n  });\n\n  // Output response\n  console.log(response.toString());\n}\n\nmain().catch(console.error);\n```\n", "start_char_idx": null, "end_char_idx": null, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "Document"}, "__type__": "4"}}}